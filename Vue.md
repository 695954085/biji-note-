
### Vue.js 是什么 ###

Vue.js是一套构建用户界面的渐进式框架，与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。Vue的核心库值关注图层，它不紧易于上手，还便于与第三方库或既有项目整合。另外一方面，当与单文件组件和Vue生态系统支持的库结合是，Vue也完全能够为复杂的单页应用程序提供驱动。

### 声明式渲染 ###

Vue.js的核心是一个允许采用简洁的模板语法来声明式的将数据渲染进Dom的系统

### 组件化应用构建 ###

组件系统是Vue的另外一个重要的概念，因为它是一种抽象，允许我们使用小型，独立和通常可服用的组件构建大型应用。

在Vue中，一个组件本质上是一个拥有预定义选线的一个Vue实例，在Vue中注册组件很简单。

### Vue实例 ###

<pre>
var vm = new Vue({
  // 选项
})
</pre>

当创建一个Vue实例时，你可以传入一个选项对象。

一个Vue应用由一个通过new Vue创建的根Vue实例，以及可选的嵌套的、可服用的组件树组成。

### 数据和方法 ###

当一个Vue实例被创建是，它向Vue的响应式系统中加入了其data对象中能找到的所有的属性。当这些属性的值大声改变时，视图将会产生‘响应’，即匹配更新为新的值。

当数据改变时，视图会进行重新渲染，值得注意的是只有当实例被创建是data中存在的属性是响应式的。

	vm.b = 'h1'

那么对b的改动将不会触发任何视图的刷新。如果你知道你会在晚些时候需要一个属性，那仅需在创建vue实例是设置一些初始值。

除了data属性，Vue实例暴露了一些有用的实例属性和方法。他们都有前缀$，以便与用户定义的属性区分开来。

	var data = { a: 1 }
	var vm = new Vue({
  		el: '#example',
  		data: data
	})
	vm.$data === data // => true
	vm.$el === document.getElementById('example') // => true
	// $watch 是一个实例方法
	vm.$watch('a', function (newValue, oldValue) {
  	// 这个回调将在 `vm.a` 改变后调用
	})

### 实例声明周期 ###

每个Vue实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到DOM、在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。

### 模板语法 ###

Vue将模板编译成虚拟的DOM渲染函数。结合响应系统，在应用状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应用到DOM操作上。

### 文本 ###

	<span>Message: {{ msg }}</span>

无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。

### 指令 ###

指令是带有`v-`前缀的特殊属性。指令属性的值预期是单个JavaScript表达式。指令的职责是，当表达式的值改变是，将其产生的连带影响，响应式地作用于DOM

### 参数 ###

一些指令能够接受一个参数，在指令名称之后以冒号表示。例如`v-bind`指令可以用于响应式地更新HTML属性。v-bind 指令可以用于响应式地更新 HTML 属性

	<a v-bind:href="url"></a>

在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。

另一个例子是 v-on 指令，它用于监听 DOM 事件：
	
	<a v-on:click="doSomething">


### 缩写 ###

`v-bind`和`v-on`可以缩写为`:`和`@`

### 计算属性和观察者 ###

### 计算属性 ###


### 计算属性和侦听属性 ###

侦听属性，当你有一些数据需要随着其他数据变化而变化时，你容易滥用watch———特别是如果你之前使用过AngularJS。


### 侦听器 ###

虽然计算属性在大多数情况下更合适，

### Class与Style 绑定 ###

操作元素的Class列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用`v-bind`处理它们：只需要通过表达式计算出字符串结果即可。不过字符串拼接麻烦且易错。因此，在将`v-bind`用于class和style时，vue.js做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。

### 条件渲染 ###

`v-if`

### 在`<template>`元素上使用v-if ###

因为v-if是一个指令，所以必须将它添加到一个元素上。

你可以使用 v-else 指令来表示 v-if 的“else 块”

v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。

`v-show`

另外一个用于根据条件展示元素的选项是`v-show`执行。

v-if是真正的条件渲染，因为它会确保切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。

v-if也是惰性的，如果在初始渲染时条件为假，则什么都不做知道到条件第一次为真实，才会真正开始渲染条件块。

相比之下，v-show就简单得多——不管初始化条件时什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。

### 列表渲染 ###

用v-for把一个数组对应为一组元素

我们用v-for指令根据一组数组的选项列表进行渲染。v-for指令需要使用item in items形式的特殊语法，items是源数据数组并且item是数组元素迭代的别名。

在`v-for`块中，我们拥有对父作用域属性的完全访问权限。v-for还支持一个可选的第二参数为当前项的索引。


### 组件 ###

### 什么是组件？ ###

组件是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义元素，vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以表现为用`is`特性进行了扩展的原生HTML元素。

### 使用组件 ###

### 全局注册 ###

要注册一个全局组件，可以使用`Vue.component(tagName,options)`。例如：

<pre>
Vue.component('my-component', {
  // 选项
})
</pre>

组件在注册之后，便可以作为自定义元素`<my-component></my-component>`在一个实例的模板中使用。注意确保在初始化根实例之前注册组件。

### 局部注册 ###

你不必把每个组件都注册到全局。你可以通过某个Vue实例/组件的实例选项`components`注册仅在其作用域中可用的组件。

### DOM模板解析注册事项 ###

当使用DOM作为模板时(例如，使用`el`选项来把Vue实例挂载到一个已有内容的元素上)。你会收到HTML本身的一些限制，因为Vue只有在浏览器解析，规范化模板之后才能获取其内容。

### data ###

构造Vue实例时传入的各种选项大多数都可以在组件里使用。只有一个例外：data必须是函数。实际上，如果你这么做：

<pre>
Vue.component('my-component', {
  template: '<span>{{ message }}</span>',
  data: {
    message: 'hello'
  }
})
</pre>

那么Vue会停止运行，并在控制台发出警告，告诉你在组件实例中data必须是一个函数。但理解这种规则为何存在也是很有益处的，所以让我们先作个弊：

### 组件组合 ###

组件设计初衷就是要配合使用的，最常见的就是形成父子组件的关系：组件A在它的模板中使用了组件B。它们之间必然需要相互通信：父组件可能要给子组件下发数据，子组件则可能要讲它内部发生的事情告知父组件。然而，通过一个良好定义的接口来尽可能将父子组件解耦也很重要的。这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。

在 Vue 中，父子组件的关系可以总结为** prop 向下传递，事件向上传递**。父组件通过 prop 给子组件下发数据，子组件通过事件给父组件发送消息。看看它们是怎么工作的。

### 使用Prop传递数据 ###

组件实例的作用域是孤立的。这意味着不能在子组件的模板内直接引用父组件的数据。父组件的数据需要通过prop才能下发到子组件中。

### 动态Prop ###

与绑定到任何普通的HTML特性想列斯，我们可以用v-bind来动态地讲prop绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导到子组件

### vue-router ###

vue-router是vue官方的路由插件，它和vue是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转。这vue-router中，则是路径之间的切换，也就是组件的切换。

### 第一个单页面应用 ###

这个单页面应用有两个路径：`/home`和`/about`，与这两个路径对应的是两个组件Home和About。

- JavaScript
	- 创建组件：创建单页面应用需要渲染的组件。
	- 创建路由：创建VueRouter实例
	- 映射路由：调用VueRouter实例的map方法
	- 启动路由：调用VueRouter实例的start方法

- HTML
	- 使用v-link指令
	- 使用`router-view`标签

### router.redirect ###

应用这首次运行时右侧是一片空白，应用通常都会有一个首页。

使用router.redirect方法将根据路径重定向到/home路径

### 执行过程 ###

当用户点击v-link指令元素时，
	- vue-router首先会去查找v-link指令的路由映射
	- 然后根据路由映射找到匹配的组件
	- 最后将组件渲染到router-view标签

### 具体路径 ###

在有些情况下，给一条路径加上一个名字能够让我们更方便地进行路径的跳转，尤其是在路径较长的时候。

### v-link ###

> v-link 是一个用来让用户在vue-router应用的不同路径间跳转的指令。该指令接收一个JavaScript表达式，并会在用户点击元素时用该表达式的值去调用router.go。

v-link会自动设置a标签的href属性。

### 路由对象 ###

在使用vue-router的应用中，路由对象会被注入每个组件中，赋值为this.$router，并且当路由切换时，路由对象会被更新。

每个组件都有一个route选项，route选项有一系列的钩子函数，在切换路由时会执行这些钩子函数。其中一个钩子函数是data钩子函数，它用于加载和设置组件的数据。

### 实例生命周期 ###

每个Vue实例在被创建之前都要经过一系列的初始化过程，例如需要设置数据监听、编译模板、挂载实例到DOM、在数据变化时更新DOM等。同时在这个过程中也会运行一些叫做声明生命钩子的函数。


计算属性顾名思义就是通过其他变量计算得来的**另一个属性**，fullName在它所依赖firstName，lastName这两个变量变化时重新计算自己的值。

vue 对数据提供一个  filter 的处理器，虽然命名为  filter  ，但是我觉得叫做数据处理器更体贴。用以在不改变的data 的情况下  输出前段需要的格式数据。

### 指定名称的slot ###

匿名slot(插槽)只能表示一个插槽。如果需要多个内容插槽，则可以为slot元素指定name属性。


---

### Vuex 入门 ###

Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。

Vuex就是前段为了方便数据的操作而建立的一个“前段数据库”。

模块间是不共享作用域的，那么B模块想要拿到A模块的数据，我们会怎么做，此时我们会去定义一个全局变量store，共享的数据叫state。

B模块拿到了A模块的数据state，但是这个数据不是一成不变的，A要操作这个数据。那么我们是不是要在这个数据——state改变的时候通知一下B？那写个自定义事件吧。

数据库要想取数据就得设置api getter。存数据就是对数据库进行修改api就叫 mutation。

### Vue data ###

Vue实例的数据对象。Vue将会递归地讲data的属性转化为getter/setter，从而让data的属性能够响应数据变化。对象必须是纯粹的对象(含有零个或多个的key/value对) 浏览器API创建的原生对象。原型上的属性会被忽略。

### Axios ###

在vue2.0的时候将推荐工具改成了axios。

使用方式都差不多，但需要注意的是：接口返回的res并不是直接返回数据，而是经过axios本身处理过的json对象。真正的数据在res.data里

<pre>
axios.get(url).then((res)=>{
  this.data = res.data
})
</pre>

### Vuex ###

vue提供了一个数据管理工具vuex，可以进行数据上的通信。比如存储一些公共变量或者是不同组件之间的数据处理等。

### Vue-Router ###

vue-router是vue的路由系统，可以用来创建单页面应用。基本思想是在主页面中引入标签，然后定义路由，把router挂载到app上，然后把各个子页面渲染到view里面。使用起来还是很方便的，跳转页面只需要

	router.push('test')

### 导航守卫 ###

vue-router提供的单行守卫主要用来通过跳转或取消的方式守卫导航。有多种机会植入路由导航过程中：全局的，单个路由独享的，或者组件级的。

记住参数或查询的改变并不会触发进入/离开的导航守卫。你可以通过观察$route对象来应对这些变化，或使用beforeRouteUpdate的组件内守卫。

### 全局守卫 ###

你可以使用router.beforeEach注册一个全局前置守卫：

<pre>
const router = new VueRouter({...})

router.beforeEach(function(to,from,next){
	...
})
</pre>

当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前一直处于等待中。

每个守卫方法接收三个参数：

- `to:Route`：即将要进入的目标路由对象
- `from:Route`：当前导航正要离开的路由
- `next:Function`： 一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数。
	- next 


### 插槽 ###

- 作用域插槽
	- 作用域插槽是一种特殊类型的插槽，用作一个可重用的模板，来代替已经渲染好的元素。
	- 在子组件中，只需将数据传递到插槽，就像你将prop传递给组件一样。
	
### 生命周期钩子 ###

所有的生命周期钩子自动绑定this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。

### debounce ###

debounce和throttle很像，debounce是空闲事件必须大于或等于一定值的时候，才会执行调用方法。debounce是空闲时间的间隔控制。比如我们做autoComplete，这时需要我们很好的控制输入文字时调用方法时间间隔。一般时第一个输入的字符马上开始调用，根据一定的时间间隔重复调用执行的方法
  

### 渲染函数&JSX ###

Vue推荐在绝大多数数情况下使用template来创建你的HTML。然而在一些场景中，你真的需要JavaScript的完全编程的能力，这就是render函数，它比template更接近编译器。

在这种场景中使用template并不是最好的选择：首先代码冗长，为了在不同级别的标题中插入锚点元素，我们需要重复地使用slot。

虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁。那么，我们来尝试使用render函数重写上面的例子

<pre>
Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,   // tag name 标签名称
      this.$slots.default // 子组件中的阵列
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
</pre>

### 自定义指令 ###

- bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- inserted ： 被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
- update： 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。听过比较更新前后值，可以忽略不必要的模板更新。
- componentUpdated ： 指令所在组件的 VNode 及其子 VNode 全部更新后调用。
- unbind ： 只调用一次，指令与元素解绑时调用。

### 开发插件 ###

插件通常会为Vue添加全局功能。插件的范围没有限制