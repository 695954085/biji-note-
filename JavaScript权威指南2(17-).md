## 17 事件处理

你可能知道，Javascript语言的执行环境是"单线程"（single thread）。

所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。

为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。

"同步模式"就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；"异步模式"则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

本文总结了"异步模式"编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。

一、回调函数

假定有两个函数f1和f2，后者等待前者的执行结果。

<pre>
f1();
f2();
</pre>

如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。

<pre>
function f1(callback){
	setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　callback();
　　　　}, 1000);
}

f1(f2);
</pre>

二、事件监听

另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

	f1.on('done', f2);

上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：

<pre>
　　function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　f1.trigger('done');
　　　　}, 1000);
　　}
</pre>

三、发布/订阅

我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。

首先，f2向"信号中心"jQuery订阅"done"信号。

	jQuery.subscribe("done", f2);

<pre>
　　function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　jQuery.publish("done");
　　　　}, 1000);
　　}
</pre>

jQuery.publish("done")的意思是，f1执行完成后，向"信号中心"jQuery发布"done"信号，从而引发f2的执行。
此外，f2完成执行后，也可以取消订阅（unsubscribe）。

<pre>
jQuery.unsubscribe("done", f2);
</pre>

这种方法的性质与"事件监听"类似，但是明显优于后者。因为我们可以通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

四、Promises对象

Promise对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。

简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如f1的回调函数f2，可以写成：

<pre>
f1().then(f2);
</pre>

f1要进行如下改写（这里使用的是jQuery的实现）：

<pre>
　　function f1(){
　　　　var dfd = $.Deferred();
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　dfd.resolve();
　　　　}, 500);
　　　　return dfd.promise;
　　}
</pre>

这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。

比如，指定多个回调函数：

	f1().then(f2).then(f3);

再比如，指定发生错误时的回调函数：
	
	f1().then(f2).fail(f3);


事件是Web浏览器通知应用程序发生什么事情。事件不是JavaScript对象，不会出现在程序源代码中。当然，会有一些事件相关的对象出现在源代码中。

事件目标是发生的事件或与之相关的对象。

事件处理程序或事件监听程序是处理或响应事件的函数。当对象上注册的事件处理程序被调用时，我们有时会说浏览器“触发”（fire,trigger）和“派发”（dispatch）了事件。

事件传播是浏览器决定哪个对象触发其事件处理程序的过程。对于单个对象的特定事件，必须是不能传播的。当文档元素上发生某个类型的特定事件，必须不能传播。当文档元素上发生某个类型的事件时，然而，它们会在文档树上向上传播或“冒泡”。
**有时，在Document或其他容器元素上注册单个事件处理程序比在每个独立的目标元素哈桑都注册处理程序更方便。事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播。**


事件传播的另外一种形式称为事件捕获，在容器元素上注册的特定处理程序
有机会再事件传播到真实目标之前拦截（或捕获）它。

### 17.2.3 addEventListener() 9/7/2016 9:43:55 AM 

所有浏览器都支持的标准事件模型中，任何能成为事件目标的对象，定义了一个名叫addEventListener方法，使用这个方法可以为事件目标注册事件处理程序。

用“click”作为第一个参数调用addEventListener不会影响onclick属性的值，能通过多次调用addEventListener为同一个对象注册同一个时间类型的多个处理程序函数。当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。

### 17.3 事件处理程序的调用

一旦注册了事件处理程序，浏览器就会在指定对象上发生指定类型事件时自动调用它。

###17.3 事件处理程序的运行环境

当通过设置属性注册事件处理程序时，事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用。在事件处理程序内，this关键字指的是事件目标。

	e.onclick = function(){}

> addEventListener同理

但是对于attachEvent，使用attachEvent注册的处理程序作为函数调用，它的this值是全局（Window）对象。

<pre>
/*
 * 在指定的事件目标注册用于处理指定类型事件的指定处理程序函数
 * 确保处理程序一直作为事件目标的方法调用
 */
function addEvent(target,type,handler){
	if(target.addEventListener){
		target.addEventListener(type,handler,false);
	}else{
		target.attachEvent("on" + type,function(event){
			//把处理程序作为事件目标的方法调用，
			//传递事件对象
			return handler.call(target,event);
		});
	}
	
}

</pre>

### 上传文件

&lt;input type="file"/&gt;元素选择文件时，表单将在它产生的POST请求主体中发送文件内容。HTML表单始终能上传文件，但到目前为止它还不能使用XMLHttpRequest API做相同的事情。

## jQuery类库 9/27/2016 2:51:21 PM 

- 本章介绍如何使用jQuery来实现简单查询并操作其结果。
- 如何设置HTML属性、css样式和类、HTML表单的值和元素内容、位置高宽，以及数据。
- 如何使用jQuery的跨浏览器事件模型。
- 如何改变文档结构：对元素进行插入、替换、包装和删除操作。
- 如何使用jQuery来实现动画视觉效果。
- jQuery的Ajax工具，如何用脚本来发起HTTP请求。
- jQuery的工具函数。
- jQuery选择器的所有语法，以及如何使用jQuery的高级选择方法。

jQuery类库定义了一个全局函数：jQuery()。快捷别名：$。这是jQuery在全局命名空间中定义的唯一两个变量。

### jQuery()函数

在jQuery类库中，最重要的方法是jQuery()方法。它的功能很强大，有4中不同的调用方法。

- 第一种也是最常见的调用方式是传递CSS选择器给$()方法。
- 第二种调用方式是传递一个Element、Document或Window对象给$()方法。
- 第三种调用方式是传递HTML文本字符串给$()方法。
- 最后一种是传入一个函数给$()方法。当文档加载完毕且DOM操作时，传入的函数将被调用。



### 19.1.2 查询与查询结果

$()的返回值是一个jQuery对象。jQuery对象是类数组：它们拥有length属性和数值属性。

	$("body").length // => 1:文档只有唯一一个body对象

如果不想把数组标识用在jQuery对象上，可以使用size()来替代length属性，用get()方法来替代方括号索引。可以使用toArray()方法来将jQuery对象转化为真实数组。

jQuery对象还有三个挺有趣的属性。selector属性是创建jQuery对象时的选择器字符串。context属性是上下文对象，是传递给$()方法的第二参数，如果没有传递的话，默认是Document对象。最后，所有jQuery对象都有一个名为jquery的属性。

jQuery的each方法和forEach区别：如果回调函数在任一个元素上返回false,遍历将在该元素后终止。

### 19.2 jQuery的getter和setter

jQuery对象上最简单、最常见的操作系统是获取（get）或设置（set）HTML属性、CSS样式、元素内容和位置高宽的值。

- jQuery使用同一个方法即当getter用又做setter用，而不是定义一对方法。如果传入一个新值给该方法，则它设置此值；如果没指定值，则它返回当前值。
- 用做setter时，这些方法会给jQuery对象中的每一个元素设置值，然后返回该jQuery对象以方便链式调用。
- 用做getter时，这些方法只会查询元素集中的第一个元素，返回单个值。getter不会返回调用自身的jQuery对象，因此它只能出现在链式调用的末尾。


### 19.2.1 获取和设置HTML属性

attr()方法是jQuery中用于HTML属性高的getter/setter

### 19.2.6 获取和设置元素的位置高宽

尤其是当浏览器不支持getBoundingClientRect()时，使用jQuery方法可以更简单地获取元素的大小和位置，并兼容所有的浏览器。

### 19.2.7 获取和设置元素数据

jQuery定义了一个名为data()的getter/setter方法，可用来设置或获取与文档元素、Document或Window对象相关联的数据。可以将数据与任意元素关联是很重要和强大的的一项功能。这是jQuery的事件处理程序注册和效果队列机制的基础。

需要将数据与jQuery对象中的元素关联，传递名称和值两个参数给data方法即可。对象的每一个属性都将用做名/值对，用来与jQuery对象的元素关联。传递对象给data时，该对象的属性将替换掉与元素相关联的旧数据。

### 19.3.2 复制元素

如果插入的元素已经是文档的一部分，这些元素只会简单地移动而不是复制到新位置。如果元素到插入不止一个位置。jQuery在需要时会赋值元素，但是当只插入一个位置时，是不会进行复制操作的。如果想赋值元素到新位置而不是移动它，必须首先用clone方法得到一个副本。

### 19.3.3 包装元素

jQuery定义了3个包装函数。wrap函数包装每一个选中元素。wrapInner包装每一个选中元素的内容。wrapAll则将选中元素作为一组来包装。这些方法通常转入一个新创建的包转元素或用来创新包装元素的HTML元素字符串。

### 19.3.4 删除元素

empty会删除每个选中元素的所有子节点（包括文本节点），但不会修改元素自身。remove会从文档中移除选中元素（以及所有元素的内容）。通常不带参数调用remove，此时会从文档中移除jQuery对象中的所有元素。


### 19.4 使用jQuery处理事件

focus和blur事件不支持冒泡，但focusin和focueout事件支持，jQuery确保这些事件在所有浏览器下都支持。相反地，mouseover和mouseout事件支持冒泡，但这经常不方便，因为很难知道鼠标是从自己感兴趣的元素中移开了，还只是从该元素的子孙元素中移开了。mouseenter和mouseleave是非冒泡事件，

resize和unload事件类型只在window对象中触发，如果想要给这两个事件类型注册处理程序，应该在$(window)上调用resize和unload方法。scroll方法经常也用于$(window)对象上，但它也经常用于在有滚动条的任何元素上。

	
	overflow
	定义与用法：overflow属性规定，定义溢出了元素内容区的内容该如何处理。
	
	可能的值
	visible 默认值。内容不会被修剪，会呈现在元素框之外。
	hidden	内容会被修剪，并且内容溢出部分时不可见。
	scroll	内容会被修剪，但是浏览器会显示滚动条必便查看溢出的内容。
	auto	如果内容被修剪，则浏览器会显示滚动条以便查看溢出的内容。如果没有溢出，就不显示滚动条。
	inherit	从父元素继承overflow属性的值。 

load方法可以在$(window)上调用，用来给窗口注册加载事件处理程序，但经常更好的选择是，直接将初始化函数传给$。

另外一个特殊的事件注册方法是toggle，该方法将事件处理程序函数绑定到单击事件。

可以传递HTML字符串给$()方法来创建该字符串所描述的元素。

可以传递HTML字符串给$()方法来创建该字符串所描述的元素，还可以传入一个对象，该对象有属性组成。此外，如果这些属性中有任何一个与上面列举的事件注册方法同名，该属性值会被当做处理程序函数，并注册为命名事件类型的处理程序。

### 19.2.4 jQuery事件处理程序

jQuery调用每一个事件处理程序时，的确传入了一个或多个参数，并且对处理程序的返回值进行了处理。每个事件处理程序都传入一个jQuery事件对象作为第一个参数。该对象的字段提供了与该事件相关的详细的信息。

jQuery事件处理程序函数的返回值都是有意义的。如果处理程序返回false，与该事件相关联的默认行为，以及该事件接下来的冒泡都会被取消。返回false等同于调用Event对象的preventDefault和stopPropagation方法。同样的，当事件处理程序返回一个值时，jQuery会将该值存储在Event对象的result属性中，该属性可以被后续调用的事件处理程序访问。

### 19.4.3 jQuery事件对象

jQuery通过定义自己的Event对象来隐藏浏览器之间的实现差异。当一个jQuery事件处理程序被调用时，总会传入一个jQuery事件对象作为其第一个参数。jQuery事件对象主要以W3C标准为基准，同时它也实现了一些实际的事件标准。

### 19.4.4 事件处理程序的高级注册

jQuery定义了相当多简单的方法来注册事件处理程序。所有这些方法都是简单地调用单一的，更复杂的方法bind来命名的时间类型绑定处理程序。

调用bind是还可以带有三个参数。事件类型是第一个参数，处理程序的函数是第三个参数。在这两个参数中间可以传入任何值，jQuery会在调用处理程序前，将指定的值设置为Event对象的data属性。通过这种方式传递额外的数据给处理程序，不需要使用闭包，有时候很有用。bind还有其他高级特性，如果第一个参数是由空格分隔的时间类型列表，则处理程序函数会为每一个命名的时间类型注册。

bind的另外一个重要特性是允许为注册的事件处理程序制定命名空间。这使得可以定义处理程序组。处理程序的命名空间对于开发可复用jQuery代码的类库或模块的程序员来说特别有用。事件命名空间类似css的类选择器。要绑定事件处理器到命名空间中时，添加句点（.）和命名空间名到事件类型字符串中即可。

bind的第一个参数可以是对象，该对象把事件名映射到处理程序函数。再次使用hover方法来说明。

