## 17 事件处理

你可能知道，Javascript语言的执行环境是"单线程"（single thread）。

所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。

这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。

为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。

"同步模式"就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；"异步模式"则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

本文总结了"异步模式"编程的4种方法，理解它们可以让你写出结构更合理、性能更出色、维护更方便的Javascript程序。

一、回调函数

假定有两个函数f1和f2，后者等待前者的执行结果。

<pre>
f1();
f2();
</pre>

如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。

<pre>
function f1(callback){
	setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　callback();
　　　　}, 1000);
}

f1(f2);
</pre>

二、事件监听

另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

	f1.on('done', f2);

上面这行代码的意思是，当f1发生done事件，就执行f2。然后，对f1进行改写：

<pre>
　　function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　f1.trigger('done');
　　　　}, 1000);
　　}
</pre>

三、发布/订阅

我们假定，存在一个"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern），又称"观察者模式"（observer pattern）。

首先，f2向"信号中心"jQuery订阅"done"信号。

	jQuery.subscribe("done", f2);

<pre>
　　function f1(){
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　jQuery.publish("done");
　　　　}, 1000);
　　}
</pre>

jQuery.publish("done")的意思是，f1执行完成后，向"信号中心"jQuery发布"done"信号，从而引发f2的执行。
此外，f2完成执行后，也可以取消订阅（unsubscribe）。

<pre>
jQuery.unsubscribe("done", f2);
</pre>

这种方法的性质与"事件监听"类似，但是明显优于后者。因为我们可以通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

四、Promises对象

Promise对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。

简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如f1的回调函数f2，可以写成：

<pre>
f1().then(f2);
</pre>

f1要进行如下改写（这里使用的是jQuery的实现）：

<pre>
　　function f1(){
　　　　var dfd = $.Deferred();
　　　　setTimeout(function () {
　　　　　　// f1的任务代码
　　　　　　dfd.resolve();
　　　　}, 500);
　　　　return dfd.promise;
　　}
</pre>

这样写的优点在于，回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。

比如，指定多个回调函数：

	f1().then(f2).then(f3);

再比如，指定发生错误时的回调函数：
	
	f1().then(f2).fail(f3);


事件是Web浏览器通知应用程序发生什么事情。事件不是JavaScript对象，不会出现在程序源代码中。当然，会有一些事件相关的对象出现在源代码中。

事件目标是发生的事件或与之相关的对象。

事件处理程序或事件监听程序是处理或响应事件的函数。当对象上注册的事件处理程序被调用时，我们有时会说浏览器“触发”（fire,trigger）和“派发”（dispatch）了事件。

事件传播是浏览器决定哪个对象触发其事件处理程序的过程。对于单个对象的特定事件，必须是不能传播的。当文档元素上发生某个类型的特定事件，必须不能传播。当文档元素上发生某个类型的事件时，然而，它们会在文档树上向上传播或“冒泡”。
**有时，在Document或其他容器元素上注册单个事件处理程序比在每个独立的目标元素哈桑都注册处理程序更方便。事件处理程序能通过调用方法或设置事件对象属性来阻止事件传播。**


事件传播的另外一种形式称为事件捕获，在容器元素上注册的特定处理程序
有机会再事件传播到真实目标之前拦截（或捕获）它。

### 17.2.3 addEventListener() 9/7/2016 9:43:55 AM 

所有浏览器都支持的标准事件模型中，任何能成为事件目标的对象，定义了一个名叫addEventListener方法，使用这个方法可以为事件目标注册事件处理程序。

用“click”作为第一个参数调用addEventListener不会影响onclick属性的值，能通过多次调用addEventListener为同一个对象注册同一个时间类型的多个处理程序函数。当对象上发生事件时，所有该事件类型的注册处理程序都会按照注册的顺序调用。

### 17.3 事件处理程序的调用

一旦注册了事件处理程序，浏览器就会在指定对象上发生指定类型事件时自动调用它。

###17.3 事件处理程序的运行环境

当通过设置属性注册事件处理程序时，事件处理程序在事件目标上定义，所以它们作为这个对象的方法来调用。在事件处理程序内，this关键字指的是事件目标。

	e.onclick = function(){}

> addEventListener同理

但是对于attachEvent，使用attachEvent注册的处理程序作为函数调用，它的this值是全局（Window）对象。

<pre>
/*
 * 在指定的事件目标注册用于处理指定类型事件的指定处理程序函数
 * 确保处理程序一直作为事件目标的方法调用
 */
function addEvent(target,type,handler){
	if(target.addEventListener){
		target.addEventListener(type,handler,false);
	}else{
		target.attachEvent("on" + type,function(event){
			//把处理程序作为事件目标的方法调用，
			//传递事件对象
			return handler.call(target,event);
		});
	}
	
}

</pre>