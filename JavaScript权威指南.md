# JavaScript 权威指南


## Day01

1. JavaScript语言核心针对文本、数组、日期和正则表达式的操作定义了很少的API，但是这些API不包括输入输出功能。输入和输出功能（类似网络、存储和图形相关的复杂特性）是由JavaScript所属的“宿主环境”提供。
	* 第一部分涵盖了语言本身的特性以及少量的内置API。
	* 第二部分讲解了JavaScript如何在Web浏览器中工作，并涵盖基于浏览器的API——称做“客户端JavaScript”。
	* 第三部分是核心API的参考手册。
	* 第四部分是客户端JavaScript参考手册

2. 函数和对象合写在一起时，函数就是变成了“方法”（method）

3. 我们也可以定义自己的方法，“this”关键字是对定义方法的对象的引用    

4. JavaScript语言核心部分的内容中的知识点交叉引用比较多，且知识点的层次感并不分明。

## Day02

### 第二章

1. JavaScript是区分大小写的语言。 HTML并不区分大小写。
2. 许多客户单JavaScript对象和属性与它们所表示的HTML标签和属性同名。在HTML中，这些标签和属性名可以使用大写或小写，而在JavaScript中则必须是小写。
3. 标识符必须以字母、下划线、美元符开始。             
4. JavaScript保留字，ECMAScript将java的所有关键字都列为自己的保留字。JavaScript预定义了很多全局变量和函数，应当避免把它们的名字用做变量名和函数名。
5. JavaScript的具体实现可能定义独有的全局变量和函数，每一种特定的JavaScript运行环境（客户端、服务器端等）都有自己的一个全局属性列表。
6. 可选分号：return、break和continue和随后的表达式之间不能有换行。
    >注意 ++ --

  　
***
### 第三章

* 在编程语言中，能够表示并操作的值的类型称做数据类型（type）
* JavaScript的数据类型为两类：原始类型（Primitive type）和对象类型（object type）
* 数据类型本身可以定义方法（Method）来使用值
* 从技术上讲，只有JavaScript对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法。在JavaScript中，只有null和undefined是无法拥有方法的值。

***
### 3.8 类型转换

* 以数字表示的字符串可以直接转化为数字，也允许在开始和结尾处带有空格。
* 原始值转换为对象也非常简单，原始值转化为各自的包装对象。
* null和undefined属于例外，当将它们转化为对象的时候会造成一个类型错误（TypeError）异常。
* 除了null和undefined之外的任何值都具有toString()方法
* 函数类的toString（）方法返回这个函数的实现定义的表示方式，这里的实现方式是通常是将用户定义的函数转换为JavaScript源代码字符串。

##Day04
### 3.10.1 函数作用域和声明提前

* 类似C语言的编程语言中，花括号内的每一段代码具有各自的作用域，块级作用域。JavaScript取而代之为函数作用域。
 > 变量在声明之前他们的函数体以及这个函数体嵌套的任意函数体内都具有定义。

* 变量声明之前甚至已经可用。
* 当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除。

***
### 第四章 表达式和运算符
* this关键字经常在面向对象编程中出现。在一个方法体内，this返回调用这个方法的对象。
* 函数也可以通过函数语句来定义，而不是函数表达式。

## Day05
### eval()

## Day06
### 声明语句
* 变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本或者函数的顶部。但是初始化的操作则还在原来var语句的位置执行，在声明语句之前变量的值是undefined。
> var语句同样可以作为for循环或者for/in循环的组成部分（和在循环之外声明的变量声明一样，这里声明的变量也会“提前”）。
> 注意，多次声明同一变量是无所谓的。

### for/in
 * JavaScript会依次枚举对象的属性来执行循环。
 * 只要for/in循环中variable的值可以当做赋值表达式的左值。
 * for/in循环并不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到。JavaScript语言核心所定义的内置方法就不是“可枚举的”。
 * 代码中定义的所有属性和方法都是可以枚举的。
 
## Day07 ##
-  debugger语句
> JavaScript解释器将会以调试模式运行。这条语句用来产生一个断点，JavaScript代码的执行会停止在断点的位置。
> 但如果调试器已经在运行中，这条语句才会真正产生一个断点。

- “user strict”
> 严格模式下，调用的函数（不是方法）中的this值是undefined。（在非严格模式下，调用的函数中的this值是全局对象），用以判断是否支持JavaScript严格模式。

- 对象
 - 对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值聚合在一起，可以通过该名字访问这个值。
 - JavaScript对象是动态的——可以新增属性也可以删除属性——但是它们常用来模拟静态对象以及静态类型语言中的“结构体”。
 - 除了字符串、数字、true、false、null和undefined之外，JavaScript中的值都是对象。
 - 属性名可以是包含字符串在内的任意字符串，但是对象中不能存在两个同名的属性。
 - 属性特征：可写、可枚举、可配置。
 - 对象的原型（protype）指向另外一个对象，本对象的属性继承自它的原型对象。
 - 对象的类（class）是一个知识对象类型的字符串。
 

## Day08 ##
- 原型：通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。
- Object.create()方法，它创建一个新对象，其中第一个参数是这个对象的原型。
- 假值是false，null，undefined，0，-0，NaN和“”。
- 在JavaScript中任何希望使用布尔值的地方，表达式和语句都会将其当做是真值或假值来对待。
- && 当左操作数是真值时，“&&”运算符将计算右操作数的值并将其返回作为整个表达式的计算结果。
- 给null和undefined设置属性也会报类型错误。
- 给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。
- delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性。
- 要删除基层属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象。
- 某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。
- 给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。
- for/in循环可以在循环体中、遍历对象中所有可枚举的属性(包括自由属性和继承属性)
- Object.keys()，它返回一个数组，这个数组由对象中可枚举的自由属性的名称组成。
- Object.getOwnPropertyNames()返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。
- 由getter和setter定义的属性称做“存取器属性”，它不同于“数据属性”，数据属性只有一个简单的值。
- 数据属性的4个特征分别是它的值、可写性、可枚举和可配置性。
- 存取器属性不具有值特性和可写性
- 存取器属性特性的4个特性是读取、写入、可枚举性和可配置性。

## Day09 ##
- Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符
- 属性描述符对象：数据属性的描述符对象的属性有value,writable,enumerable和configurable。
- 存取器属性的描述符对象则用get属性和set属性，enumeratable和configurable。
- 函数的定义会包括一个称为形参的标识符列表，这些参数在函数体中像局部变量一样工作。
- 除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——这就是this关键字的值。
- 如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。
- 函数即是对象，程序可以随意操纵它们。因为函数是对象，所以可以给它们设置属性，甚至调用它们的方法。
- JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。

## Day10 ##
- 尽管函数声明语句和函数定义表达式包含相同的函数名，但二者仍然不同。两种方式都创建了新的函数对象，但函数对象声明语句中的函数名是一个变量名，变量指向函数对象。
- 函数定义表达式使用var的话，只有变量声明提前了——变量的初始化代码仍然在原来的文职。然而使用函数声明语句的话，函数名称和函数体均被提前。
- 函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。注意，此限制仅适用于语句声明形式定义的函数。函数定义表达式可以出现在JavaScript代码的任何地方。
- 如果这个表达式是一个属性访问表达式，那个这个调用称做“方法调用”。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。
- var strict = (function(){return !this;}()); //用于判断当前是否为严格模式。
- 任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。
- this是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给this赋值。
- 和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法滴阿用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象就是undefined。
- 如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。
> 凡是没有形参的构造函数调用都可以省略括号

## Day11 ##
- 运算符“||”，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。
> 需要注意的是，需要将可选实参放在实参列表的最后。
> 同时注意在函数定义中使用注释/*optional*/来强调形参是可选的。

- 在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值。

## Day12 ##
- 不定实参函数的实参个数不能为0，arguments[]对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必须参数，以及随后个数不定的可选参数。
> arguments是一个对象，只是碰巧具有以数字为索引的属性。

- 非严格模式下，callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现这个属性，这指代当前正在执行的函数的函数。
> 实参对象（arguments）定义了callee和caller属性。

- 最好通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。
- 所有的原始类型都可以转换成字符串。所有对象都包含toString()方法。
> 除非所写的函数是只用到一两次的“用完即丢”的函数，你应当添加类似的实参类型检查逻辑，因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错。相比而言，逻辑执行时的报错消息不甚清晰且更难处理。、

- 函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。
- 函数并不是原始值，而是一种特殊的对象。也就是说，函数可以拥有属性。
- 在函数中声明的变量在整个函数体内都是可见的（包括在嵌套函数中）。在函数体外是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的。

## Day13
- 嵌套的函数不会将作用域内的私有成员赋值一份，也不会对所绑定的变量生成静态快照。
- 函数是值，对函数执行typeof运算会返回字符串“function”，但是函数是JavaScript中的特殊对象。因为他们是对象，也可以拥有属性和方法。
- 每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称为“原型对象”。每一个函数都包含不同的原型对象。

## Day14
- 高阶函数：就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数。

----------

- array.every(callback[, thisObject]);

**下面是参数的详细信息：**

1. callback : 函数用来测试每个元素
2. thisObject : 对象作为该执行回调时使用

----------


- 数组的map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。
- call()方法和apply()方法看做是某个对象的方法，通过调用方法的形式的来简介调用函数
> call()方法使用方法自有的实参列表作为函数的实参，apply()方法则要求以数组的形式传入参数。

    //f函数自有的实参列表f(x,y)
    f.call(o,1,2)
    f.apply(o,[1,2])

- 在JavaScript中，类的实现是基于其原型继承机制的，如果两个对象继承自同一个原型，往往意味着它们是由同一个构造函数创建并初始化的。
- JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。
- 通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象。
- 任何类的方法都可以通过this的这种基本用法来读取对象的属性
- 使用关键字new来调用构造函数会自动创建一个新对象，因此构造函数本身只需要初始化这个新对象的状态即可。
- 调用构造函数的一个重要特征是，构造函数的prototype属性被用做新对象的原型。这就意味着通过同一个构造函数创建的所有对象都继承自相同一个对象，因此它们都是同一个类的成员。

## Day15
- 从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写，而普通的函数和方法都是首字母小写。
- 构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个心对象。
- 构造函数对象，任何添加到构造函数对象中的属性都是类字段和类方法。（如果属性值是函数的话就是类方法）。
- 原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。
- 实例对象，类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。

----------
#### 在JavaScript中定义类的步骤 ####
1. 先定义一个构造函数，并设置初始化新对象的类属性。
2. 给构造函数的prototype对象定义实例的方法。
3. 给构造函数定义类字段和类属性


----------
- JavaScript私有属性可以使用闭包里的局部变量来模拟。
- JavaScript中基于原型的继承机制是动态的，如果创建对象之后原型的属性发生改变，也会影响到继承的这个原型的所有实例对象。
- instanceof 左操作数是待检测其类的对象，右操作数是定义类的构造函数。
> 尽管instanceof运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。

## Day16 ##
- 一种合理的看法把拥有一个数值length属性和对应非负数整数属性的对象看做是一种类型的数组。“类数组对象”
> 真正的数组的length属性有一些独有的行为：当添加新的元素时，数组的长度会自动更新，并且当给length属性设置一个更小的整数时，数组会自动截断。

- 集合（set）用来表示非重复值的无序集合。
> JavaScript的对象是属性名以及与之对应的值的基本集合。

- 检测属性：JavaScript对象可以看做属性的集合，我们精诚会检测集合中成员的所属关系——判断某个属性是否存在某个对象中。
> 可以使用in运算符、hasOwnPrePerty()和propertyIsEnumerable()方法。



1. in运算符的左侧是属性名，右侧是对象。如果对象的自由属性或继承属性中包含这个属性返回true；
2. 对象的hasOwnProperty方法用来检测给定的名字是否是对象的自有属性。继承属性返回false；
3. propertyIsEnumerable方法是只有检测到自有属性且这个属性的可枚举行为true时它才返回true；


----------
- Window对象是所有客户端JavaScript特性和API的主要接入点。它表示Web浏览器的一个窗口或窗体，并且可以用标识符window来引用它。
- Window对象也是全局对象。这就意味着Window对象处于作用域链的顶部，它的属性和方法实际上是全局变量和全局函数。
- Window对象有一个引用自身的属性，叫做window。如果需要引用窗口对象本身，可以用这个属性。
- Document对象表示显示在窗口中的文档。
- Window、Document和Element对象上另外一个重要的属性集合是实际处理程序相关的属性。可以再脚本中为之绑定一个函数，这个函数会在某个事件发生时以异步的方式调用。
- Window对象的onload处理程序是最重要的事件处理程序之一。当显示在窗口中的文档内容稳定并可以操作时会触发它。

## Day17 ##
- 对象类型转换所用到的重要方法时，有一些方法是在需要做类型转换是由JavaScript解释器自动调用的。
- 标准的类型转换：toString()。这个方法返回一个可以表示这个对象的字符串。
- toLocalString是以本地敏感性的方式来将对象转换为字符串。
- valueOf用来将对象转换为原始值。
- toJSON：JSON格式用来序列化良好的数据结构，而且可以处理JavaScript原始值，数组和纯对象。
> JSON它与类无关，当对一个对象执行序列化操作时，它会忽略对象的原型和构造函数。

## Day18 ##
- 该实现的思想是：获取鼠标点击的表头单元格的列号，遍历数据行，获取每个<tr>中的html，同时获取每个<tr>标签下对应获取到的列号的<td>标签中的内容，并取得<th>标签的type属性值，将获取<tr>的html、<td>的内容和<th>的type属性值拼接成字符串添加到数组array中，然后将表格<tr>中的html全部置空，根据type属性值的不同采用不同的方法对<td>的内容进行比较，根据比较结果对数组array进行排序，然后将排序后的数组元素重新赋值给已经置空的<tr>。如果已经对该列排序过了，则直接对数组进行倒置。

## Day19 ##
- 私有属性：在经典的面向对象编程中，经常需要将对象的某个状态封装或隐藏在对象内，只有通过对象的方法才能访问这些状态，对外只暴露一些重要的状态变量可以直接读写。
- 将变量（或参数）闭包在一个构造函数内来模拟实现私有实例字段，调用构造函数会创建一个实例。
- 需要在构造函数内部定义一个函数，并将这个函数赋值给新创建对象的属性。
- JavaScript中是可以定义多个构造函数继承自一个原型对象的。
- JavaScript中创建子类的关键
    `B.prototype = inherit(A.prototype);
    B.prototype.constructor = B;`

## Day20 ##
1. 所有单独的js代码公用一个全局Document对象。这意味着它们都可以看到相同的Document对象，可以共享相同的全局函数和变量的集合。

## Day21 ##
1. for/each循环并不是遍历对象的属性，而是遍历属性的值；for/in循环遍历属性。
2. 迭代器是一个对象，这个对象允许对它的值集合进行遍历，并保持任何必要的状态。
3. 迭代器必须包含next方法。

   <pre>
      function counter(){
      	let nextValue = Math.round(start);
        return {next:function(){ return nextValue++;}};
      }
      let serialNumberGenerator = counter(100);
      let sn1 = serialNumberGenerator.next();
      let sn2 = serialNumberGenerator.next();
   </pre>
4. StopIteration是JavaScript的全局对象的属性。它的值是一个普通的对象，只是为了终结迭代的目的而保留的一个对象。
5. 我们并不是经常直接使用迭代器对象，而是使用可迭代的对象。可迭代对象表示一组可迭代处理的值。可迭代对象必须定义一个名叫_iterator_()方法，用以返回这个集合的迭代对象。
6. 我们在创建一个可迭代的对象和它的迭代器的时候，尽管必须写一个
7. JavaScript语言核心针对文本、数组、日期和正则表达式的操作定义了很少的API，但是这些API不包括输入输出功能（类似网络、存储和图形相关的复杂特性）是由JavaScript所属的“宿主环境”提供的。
8. 语句和表达式之间有很多共同处，粗略地讲，表达式仅仅计算出一个值但并不作任何操作，，它并不改变程序的运行状态。而语句并不包含一个值，但它们改变程序的运行状态。
<pre>
	var points = [
		{x:0,y:0}.
		{x:1,y:1}
	];
	
	points.dist = function(){ 
		var p1 = this[0]; //this关键字获得对当前数组的引用
		var p2 = this[1]; //并取得调用的数组的引用
        ...
		return Math.sqrt(...);
	};
	points.dist()
</pre>

- JavaScript来操控Web浏览器中的HTML内容和文档的CSS样式，同样，也可以通过事件处理程序来定义文档的行为。事件处理程序是一个在浏览器中注册的JavaScript函数，当特定类型的事件发生时浏览器便调用这个函数。
- 事件处理函数是一个在浏览器中注册的JavaScript函数，当特定类型的事件发生时浏览器便调用这个函数。
- XMLHttpRequest，在返回数据之前，注册了一个时间处理函数，这个处理函数将会在服务器的响应返回至客户端的时候调用这种异步编程模型在客户端JavaScript中是非常常见的。


## 词法结构 ##
- js区分大小写，html不区分大小写
- JavaScript解释器有自己的内存管理机制，可以自动对内存进行垃圾回收。这意味着程序可以按需创建对象，程序员则不必担心这些对象的销毁和内存回收。当不再有任何引用指向一个对象，解释器就会知道这个对象没用了，然后自动回收它多用的内存资源。
- JavaScript的类型可以分为原始类型和对象类型，也可以分为拥有方法的类型和不能拥有方法的类型，同样可分为可变类型和不可变类型。可变类型就是指可以被修改。对象和数组属于可变类型。

## 8/17/2016 9:38:40 AM  ##
- JavaScript第一次添加到Web服务器时，还没有API可以用来遍历和操作文档的结构和内容。当文档还在载入时，JavaScript影响文档内容的唯一方法是快速生成内容。
> 当HTML解析器遇到script标签时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。但是如果脚本源代码是一个由src属性指定的外部文件时，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。

- 脚本的执行只是在默认情况下是同步和阻塞的。script标签可以有defer和async属性，这可以改变脚本的执行方式。只有在和src属性联合使用时才有效。
> defer属性是的浏览器延迟脚本的执行，async属性使得浏览器可以尽快地执行脚本，而不用在下载脚本是阻塞文档解析。

- 事件驱动的JavaScript：只是把函数本身赋值给这些属性。浏览器会在事件发生时执行调用。
- 有些事件的目标是文档元素，它们会经常往上传递给文档树，这个过程叫做“冒泡”。
- 如果需要为一个事件注册多个事件处理程序函数，或者如果想要写一个可以安全注册事件处理程序的代码模块，就算另一个模块已经为相同的目标上的相同的事件注册了一个处理程序，也需要用到另一个事件处理程序注册技术。
- JavaScript语言核心并不包括任何线程机制，并且客户端JavaScript传统上也没有定义任何线程机制。HTML5定义了一种作为后台线程的“WebWorker”，但是客户端JavaScript还像严格的单线程一样工作。
- 单线程执行是为了让编程更加简单。编写代码时可以确保两个事件处理程序不会同一时刻执行，操作文档内容是也不必担心会有其他线程试图同时修改文档，并且永远不需要再写JavaScript代码的时候会担心锁，死锁和竞态条件。
- 单线程执行意味着浏览器必须在脚本和事件句处理程序执行的时候停止响应用户输入。这就意味着JavaScript脚本和事件处理程序不能运行太长时间。
- 如果应用程序不得不执行太多的计算而导致明显的延迟，应该允许文档在执行这个计算之前完全载入，并确保能够告知用户计算正在进行并且浏览器没有挂起。
- “Web worker”是一个用来执行计算密集任务而不冻结用户界面的后台线程。运行在web worker线程里的代码不能访问文档内容。不能和主线程或其他worker共享状态，只可以和主线程和其他worker通过异步事件进行通信，所以主线程不能检测并发性。

## 8/17/2016 1:45:46 PM 13.3.4 客户端JavaScript时间线 ##
- Web浏览器创建Document对象，并且开始解析Web页面，解析HTML元素和它们的文本内容后添加Element对象和Text节点到文档中。
- setTimeout返回一个值，这个值可以传递给clearTimeout()用于取消这个函数的执行。
- setInterval返回一个值，这个只可以传递给clearInterval用于取消后续函数的调用。
- 方法confirm()和prompt()都会产生阻塞，也就是说，在用户关掉它们所显示的对话框之前，它们不会返回。这就意味着在弹出一个对话框前，代码就会停止运行。

## 8/18/2016 11:06:22 AM 9.9 模块 ##
- 类让代码更加模块化。
- 模块是一个独立的JavaScript文件。模块文件可以包含一个类定义，一组相关的类、一个实用函数库或者是一些待执行的代码。
- 模块化的目标是支持大规模的程序开发，处理分散源中代码的组装，并且能让代码正确运行，哪怕包含了作者所不期望出现的模块代码。
- 不同的模块必须避免修改全局执行上下文，因此后续模块应当在它们所期望运行的原始上下文中执行。模块应该尽可能少地定义全局标识。

### 8/18/2016 11:20:20 AM 9.9.1 用做命名空间的对象
- 在模块对象创建过程中避免污染全局变量的一种方法是使用一个对象作为命名空间。它将函数和值作为命名空间对象属性存储起来，而不是定义全局函数和变量。
- 模块对外导出一些公用API，这些API是提供给其他程序员使用的，它包括函数、类、属性和方法。
- 可以将模块定义在某个函数的内部来实现。在一个函数中定义的变量和函数都属于函数的局部成员，在函数的外部是不可见的。实际上，可以将这个函数作用域用做模块的私有命名空间。
- 可以通过将模块定义在某个函数的内部来实现。
- 一旦将模块代码封装进一个函数，就需要一些方法导出其公用API，以便在模块函数的外部调用它们。


## 15 脚本化文档 8/18/2016 2:27:38 PM  ##
客户端JavaScript的存在使得静态的HTMl文档变成了交互式的Web应用。

每个Window对象有一个document属性引用了Document对象。Document对象表示窗口的内容，它就是本章的主题。

15.1 Dom浏览  
文档对象模型（DOM）是表示和操作HTML和XML文档内容的基础API。HTML文档的树状结构包含表示HTML标签或元素和表示文本字符串的节点

## 15.2.4 通过CSS类选取元素 8/19/2016 2:41:09 PM  ##
HTML 元素的class属性值是一个以空格隔开的列表，可以为空或包含多个标识符。它描述一个方法来定义多组相关的文档元素。
15.3.1 作为节点树的文档
Document对象、它的Element对象和文档中表示文本的Text对象都是Node对象。
Node 定义了一下的重要的属性：  
parentNode：该及节点的父节点。  
childNodes:只读的类数组对象，它是该节点的子节点的实时表示。  
firstChild、lastChild  
nextSibilng、previousSibiling  
nodeType  
nodeValue  
nodeName
  
15.4.3 数据集合属性  

data-XXX

15.6.1 创建节点
  
Text节点用类似的方法创建

	var newnode = document.createTextNode("text node content");

15.6.2 插入节点

一旦有了一个新节点，就可以用Node的方法appendChild或insertBefore将它插入到文档中。appendChild是在需要插入的Element节点上调用的，它插入指定的节点使其成为那个节点的最后一个子节点。

例子15-4：表格的行排序
<pre><code>
// Sort the rows in first <tbody> of the specified table according to
// the value of nth cell within each row. Use the comparator function
// if one is specified. Otherwise, compare the values alphabetically.
function sortrows(table, n, comparator) {
    var tbody = table.tBodies[0]; // First <tbody>; may be implicitly created
    var rows = tbody.getElementsByTagName("tr"); // All rows in the tbody
    rows = Array.prototype.slice.call(rows,0);   // Snapshot in a true array

    // Now sort the rows based on the text in the nth <td> element
    rows.sort(function(row1,row2) {
        var cell1 = row1.getElementsByTagName("td")[n];  // Get nth cell
        var cell2 = row2.getElementsByTagName("td")[n];  // of both rows
        var val1 = cell1.textContent || cell1.innerText; // Get text content
        var val2 = cell2.textContent || cell2.innerText; // of the two cells
        if (comparator) return comparator(val1, val2);   // Compare them!
        if (val1 < val2) return -1;
        else if (val1 > val2) return 1;
        else return 0;
    });

    // Now append the rows into the tbody in their sorted order.
    // This automatically moves them from their current location, so there
    // is no need to remove them first. If the <tbody> contains any
    // nodes other than <tr> elements, those nodes will float to the top.
    for(var i = 0; i < rows.length; i++) tbody.appendChild(rows[i]);
}

// Find the <th> elements of the table (assuming there is only one row of them)
// and make them clickable so that clicking on a column header sorts
// by that column.
function makeSortable(table) {
    var headers = table.getElementsByTagName("th");
    for(var i = 0; i < headers.length; i++) {
        (function(n) {  // Nested funtion to create a local scope
            headers[i].onclick = function() { sortrows(table, n); };
        }(i));          // Assign value of i to the local variable n
    }
}

</code></pre>

> 其中 rows = Array.prototype.slice.call(rows,0);  
> 理解可以参考：[http://www.cnblogs.com/littledu/archive/2012/05/19/2508672.html](http://www.cnblogs.com/littledu/archive/2012/05/19/2508672.html)  
<pre>
Array.prototype.slice = function(start,end){
     var result = new Array();
     start = start || 0;
     end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键
     for(var i = start; i < end; i++){
          result.push(this[i]);
     }
     return result;
}
</pre>
this指向rows对象。  

## 6.6 属性getter和setter 8/23/2016 10:46:55 AM  ##
- 由getter和setter定义的属性称做“存取器属性”，它不同于“数据属性”，数据属性只有一个简单的值。
- 当程序查询存取器属性的值时，JavaScript调用setter方法（无参数）。这个方法的返回值就是属性存取表达式的值，当程序设置一个存取器属性的值时，JavaScript调用setter方法，将赋值表达式右侧的值当做参数传入setter。
- 和数值属性不同，存取器属性不具有可写性。如果属性同时具有getter和setter方法，可读写。
<pre><code>
var o = {
	//普通的数据属性
	data_prop:value,
	
	//存取器属性都是成对定义的函数
	get accessor_prop(){},
	set accessor_prop(value){}
}；
</code></pre>

## 15.6.4 使用DocumentFragment 8/23/2016 11:27:59 AM  ##
- DocumentFragment是一种特殊的Node,它作为其他节点的一个临时的容器。
- DocumentFragment的特殊之处在于它使得一组节点被当做一个节点看待。

## 15.7 生成目录表 8/23/2016 2:02:16 PM  ##

## 18 脚本化HTTP ##
- 当用脚本设置设置Window对象的location属性或调用表单对象的submit方法时，都会初始化HTTP请求。
- 本章说明在没有导致Web浏览器重新加载任何窗口或窗体的内容情况下，脚本如何实现Web浏览器与服务器之间的通信。


## 8.2.2 方法调用 8/24/2016 10:45:14 AM  ##

和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象就好undefined。很多人误以为调用嵌套函数是this会指向调用外层函数的上下文。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。

## 8.2.4 间接调用##
JavaScript中的函数也是对象，和其他JavaScript对象没什么两样函数对象也可以包含方法。其中的两个方法call和apply可以用来间接调用函数。两个方法都允许显式指定调用所需的this的值，也就是说，任何函数可以作为任何对象的方法来调用。哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call方法使用它自有的实参列表作为函数的实参。apply方法则要求以数组的形式传入实参。

## 8.1 嵌套函数 p168 ##

在JavaScript里，函数可以嵌套在其他函数里。

<pre>
function hypotenuse(a,b){
	function square(x){returen x*x;}
	return Math.sqrt(square(a) + square(b));
}
</pre>

嵌套函数可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，内部函数square可以读取外部函数hypotenuse定义的a和b。

## 8.5 作为命名空间的函数 8/24/2016 3:03:48 PM ##
在JavaScript中是无法声明只在一个代码块内可见的变量的，基于这个原因，我们常常简单地定义了一个函数声明用做临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。

## 15.8 文档和元素的几何形状和滚动 ##
到目前为止我们考虑的文档被看成是元素和文本节点的抽象树。但是当浏览器在窗口中渲染文档时，它创建文档的一个视觉表现层，在那里每个元素有自己的位置和尺寸。
本节阐述了在浏览器窗口中完成文档的布局以后，怎样才能在抽象的基于树的文档模型与几何形状的基于坐标的视图之间来回变换。

## 15.8.1 文档坐标和视口坐标 ##
元素的位置是以像素来度量的，向右代表X坐标的增加，向下代表Y坐标的增加。但是有两个不同的点作为坐标系的原点：元素的X和Y坐标可以相对于文档的左上角或相对于其中显示文档的视口的左上角。在顶级窗口和标签页中，“视口”只是实际显示文档内容的浏览器的一部分：它不包括浏览器“外壳”。当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口坐标。

如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角，文档和视口坐标系统是同一个。但是，一般来说，要在两种坐标系之间互相转换，必须加上或减去滚动的迁移量。

文档坐标比视口坐标更加基础，并且在用户滚动时它们不会发生变化。不过，在客户编程中使用视口坐标是非常常见的。当使用css指定元素的位置时运用了文档坐标。但是，最简单的产寻元素位置的方法返回视口坐标中的位置。当为鼠标事件注册事件处理函数时，报告的鼠标指针的坐标是在视口坐标系中的。

为了在坐标系之间互相转换，我们需要判定浏览器窗口的滚动条的位置。Window对象的pageXOffset和pageYOffset属性在所有的浏览器中提供这些值。也可以通过scrollLeft和scrollTop属性来获得滚动条的位置。

### 15.8.2 查询元素的几何尺寸 ###
判定一个元素的尺寸和位置最简单的方法是调用它的getBoundingClientRect方法。

### 15.8.3 判断元素在某点
判断在视口中的指定位置上有什么元素。这可以用Document对象的elementFromPoint方法来判定。
elementFromPoint方法看上去很有用，典型的案例是将鼠标坐标传递给它来判定鼠标在那个元素上。

## 15.9 HTML表单 ##
在服务端程序中，表单必须有一个“提交”按钮。另外一个方面，在客户端编程中，“提交”按钮不是必须的。

## 15.10 其他文档特性 ##

### 15.10.1 Document的属性

## 16 脚本化css ##
CSS定义了这些属性以指定字体、颜色、外边距、边框、背景图片、文本对齐方式、元素尺寸和元素位置。通常将单独的HTML元素与CSS样式分开并把它们定义在一个样式表（stylesheet）。

用style标签把一个css样式包起来放在head标签里，他就和HTML文档关联起来了。

### 16.1.3 复合属性
某些经常在一起使用的样式属性可以组合起来使用一个特殊的复合属性。

## 16.2 重要的css属性 ##

### 16.2.1 用CSS定位元素
static   
默认属性。指定元素按照常规的文档内容流进行定位。静态定位的元素不能使用top、left和类似其他属性定位。欲对文档元素使用CSS定位技术，必先将其position属性设置为除此之外的其他3个属性值。

absolute  
该值指定元素是相对于它包含的元素进行定位。相对于所有其他的元素，绝对定位的元素是独立定位的，它不是静态定位的元素中文档流的一部分。它的定位要么是相对于最近的定位祖先元素，要么是相对于文档本身。

fixed  
该值指定元素是相对于浏览器窗口进行定位的。固定定位的元素总是显示在那里，不会随着文档其他部分为滚动。类似绝对定位的元素，固定定位的元素和所有其他元素是独立的，它不是文档流的一部分。

relative  
当position属性设置为relative，元素按照常规的文档流进行布局，它的定位相对于它文档流中的位置进行调整。系统保留着元素在正常文档流中的空间。

一旦设置了元素的position属性为除了static以外的值，就可以通过元素的left、top、right和bottom属性的一些组合指定元素的位置。

请牢记，没必要给每一个动态元素指定尺寸，某些元素具有固有尺寸。而且，对包含文本或其他流式内容的动态元素指定想要的宽度就足够了，让元素内容布局来自动决定他的高度。

### 16.3 脚本化内联样式 9/5/2016 4:14:15 PM 

style属性不同寻常：它的值不是字符串，而是一个CSSStyleDeclaration对象。CSSStyleDeclaration属性名的格式应该是移除连字符，将每个连字符后面紧连接着的字母大写。


### 16.6.1 开启和关闭样式表

最简单的脚本化样式表的技术是最便捷和健壮的。&lt;style&gt;、&lt;link&gt;元素和CSSStyleSheet对象都定义了一个在JavaScript中可以设置和查询的disabled属性。顾名思义，如果disabled属性为true，样式表就被浏览器关闭并忽略。

### 16.6.2 查询、插入与删除样式表规则

CSSStyleSheet对象有一个cssRules[]数组

