# JavaScript 权威指南


## Day01

1. JavaScript语言核心针对文本、数组、日期和正则表达式的操作定义了很少的API，但是这些API不包括输入输出功能。输入和输出功能（类似网络、存储和图形相关的复杂特性）是由JavaScript所属的“宿主环境”提供。
	* 第一部分涵盖了语言本身的特性以及少量的内置API。
	* 第二部分讲解了JavaScript如何在Web浏览器中工作，并涵盖基于浏览器的API——称做“客户端JavaScript”。
	* 第三部分是核心API的参考手册。
	* 第四部分是客户端JavaScript参考手册

2. 函数和对象合写在一起时，函数就是变成了“方法”（method）

3. 我们也可以定义自己的方法，“this”关键字是对定义方法的对象的引用    

4. JavaScript语言核心部分的内容中的知识点交叉引用比较多，且知识点的层次感并不分明。

## Day02

### 第二章

1. JavaScript是区分大小写的语言。 HTML并不区分大小写。
2. 许多客户单JavaScript对象和属性与它们所表示的HTML标签和属性同名。在HTML中，这些标签和属性名可以使用大写或小写，而在JavaScript中则必须是小写。
3. 标识符必须以字母、下划线、美元符开始。             
4. JavaScript保留字，ECMAScript将java的所有关键字都列为自己的保留字。JavaScript预定义了很多全局变量和函数，应当避免把它们的名字用做变量名和函数名。
5. JavaScript的具体实现可能定义独有的全局变量和函数，每一种特定的JavaScript运行环境（客户端、服务器端等）都有自己的一个全局属性列表。
6. 可选分号：return、break和continue和随后的表达式之间不能有换行。
    >注意 ++ --

  　
***
### 第三章

* 在编程语言中，能够表示并操作的值的类型称做数据类型（type）
* JavaScript的数据类型为两类：原始类型（Primitive type）和对象类型（object type）
* 数据类型本身可以定义方法（Method）来使用值
* 从技术上讲，只有JavaScript对象才能拥有方法。然而，数字、字符串和布尔值也可以拥有自己的方法。在JavaScript中，只有null和undefined是无法拥有方法的值。

***
### 3.8 类型转换

* 以数字表示的字符串可以直接转化为数字，也允许在开始和结尾处带有空格。
* 原始值转换为对象也非常简单，原始值转化为各自的包装对象。
* null和undefined属于例外，当将它们转化为对象的时候会造成一个类型错误（TypeError）异常。
* 除了null和undefined之外的任何值都具有toString()方法
* 函数类的toString（）方法返回这个函数的实现定义的表示方式，这里的实现方式是通常是将用户定义的函数转换为JavaScript源代码字符串。

##Day04
### 3.10.1 函数作用域和声明提前

* 类似C语言的编程语言中，花括号内的每一段代码具有各自的作用域，块级作用域。JavaScript取而代之为函数作用域。
 > 变量在声明之前他们的函数体以及这个函数体嵌套的任意函数体内都具有定义。

* 变量声明之前甚至已经可用。
* 当使用var声明一个变量时，创建的这个属性是不可配置的，也就是说这个变量无法通过delete运算符删除。

***
### 第四章 表达式和运算符
* this关键字经常在面向对象编程中出现。在一个方法体内，this返回调用这个方法的对象。
* 函数也可以通过函数语句来定义，而不是函数表达式。

## Day05
### eval()

## Day06
### 声明语句
* 变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“提前”至脚本或者函数的顶部。但是初始化的操作则还在原来var语句的位置执行，在声明语句之前变量的值是undefined。
> var语句同样可以作为for循环或者for/in循环的组成部分（和在循环之外声明的变量声明一样，这里声明的变量也会“提前”）。
> 注意，多次声明同一变量是无所谓的。

### for/in
 * JavaScript会依次枚举对象的属性来执行循环。
 * 只要for/in循环中variable的值可以当做赋值表达式的左值。
 * for/in循环并不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到。JavaScript语言核心所定义的内置方法就不是“可枚举的”。
 * 代码中定义的所有属性和方法都是可以枚举的。
 
## Day07 ##
-  debugger语句
> JavaScript解释器将会以调试模式运行。这条语句用来产生一个断点，JavaScript代码的执行会停止在断点的位置。
> 但如果调试器已经在运行中，这条语句才会真正产生一个断点。

- “user strict”
> 严格模式下，调用的函数（不是方法）中的this值是undefined。（在非严格模式下，调用的函数中的this值是全局对象），用以判断是否支持JavaScript严格模式。

- 对象
 - 对象是JavaScript的基本数据类型。对象是一种复合值：它将很多值聚合在一起，可以通过该名字访问这个值。
 - JavaScript对象是动态的——可以新增属性也可以删除属性——但是它们常用来模拟静态对象以及静态类型语言中的“结构体”。
 - 除了字符串、数字、true、false、null和undefined之外，JavaScript中的值都是对象。
 - 属性名可以是包含字符串在内的任意字符串，但是对象中不能存在两个同名的属性。
 - 属性特征：可写、可枚举、可配置。
 - 对象的原型（protype）指向另外一个对象，本对象的属性继承自它的原型对象。
 - 对象的类（class）是一个知识对象类型的字符串。
 

## Day08 ##
- 原型：通过关键字new和构造函数调用创建的对象的原型就是构造函数的prototype属性的值。
- Object.create()方法，它创建一个新对象，其中第一个参数是这个对象的原型。
- 假值是false，null，undefined，0，-0，NaN和“”。
- 在JavaScript中任何希望使用布尔值的地方，表达式和语句都会将其当做是真值或假值来对待。
- && 当左操作数是真值时，“&&”运算符将计算右操作数的值并将其返回作为整个表达式的计算结果。
- 给null和undefined设置属性也会报类型错误。
- 给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。
- delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性。
- 要删除基层属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象。
- 某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。
- 给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。
- for/in循环可以在循环体中、遍历对象中所有可枚举的属性(包括自由属性和继承属性)
- Object.keys()，它返回一个数组，这个数组由对象中可枚举的自由属性的名称组成。
- Object.getOwnPropertyNames()返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。
- 由getter和setter定义的属性称做“存取器属性”，它不同于“数据属性”，数据属性只有一个简单的值。
- 数据属性的4个特征分别是它的值、可写性、可枚举和可配置性。
- 存取器属性不具有值特性和可写性
- 存取器属性特性的4个特性是读取、写入、可枚举性和可配置性。

## Day09 ##
- Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符
- 属性描述符对象：数据属性的描述符对象的属性有value,writable,enumerable和configurable。
- 存取器属性的描述符对象则用get属性和set属性，enumeratable和configurable。
- 函数的定义会包括一个称为形参的标识符列表，这些参数在函数体中像局部变量一样工作。
- 除了实参之外，每次调用还会拥有另外一个值——本次调用的上下文——这就是this关键字的值。
- 如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。
- 函数即是对象，程序可以随意操纵它们。因为函数是对象，所以可以给它们设置属性，甚至调用它们的方法。
- JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。

## Day10 ##
- 尽管函数声明语句和函数定义表达式包含相同的函数名，但二者仍然不同。两种方式都创建了新的函数对象，但函数对象声明语句中的函数名是一个变量名，变量指向函数对象。
- 函数定义表达式使用var的话，只有变量声明提前了——变量的初始化代码仍然在原来的文职。然而使用函数声明语句的话，函数名称和函数体均被提前。
- 函数声明语句不能出现在循环、条件判断、或者try/catch/finally以及with语句中。注意，此限制仅适用于语句声明形式定义的函数。函数定义表达式可以出现在JavaScript代码的任何地方。
- 如果这个表达式是一个属性访问表达式，那个这个调用称做“方法调用”。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。
- var strict = (function(){return !this;}()); //用于判断当前是否为严格模式。
- 任何函数只要作为方法调用实际上都会传入一个隐式的实参——这个实参是一个对象，方法调用的母体就是这个对象。
- this是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给this赋值。
- 和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法滴阿用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象就是undefined。
- 如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。
> 凡是没有形参的构造函数调用都可以省略括号

## Day11 ##
- 运算符“||”，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。
> 需要注意的是，需要将可选实参放在实参列表的最后。
> 同时注意在函数定义中使用注释/*optional*/来强调形参是可选的。

- 在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值。

## Day12 ##
- 不定实参函数的实参个数不能为0，arguments[]对象最适合的应用场景是在这样一类函数中，这类函数包含固定个数的命名和必须参数，以及随后个数不定的可选参数。
> arguments是一个对象，只是碰巧具有以数字为索引的属性。

- 非严格模式下，callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现这个属性，这指代当前正在执行的函数的函数。
> 实参对象（arguments）定义了callee和caller属性。

- 最好通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。
- 所有的原始类型都可以转换成字符串。所有对象都包含toString()方法。
> 除非所写的函数是只用到一两次的“用完即丢”的函数，你应当添加类似的实参类型检查逻辑，因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错。相比而言，逻辑执行时的报错消息不甚清晰且更难处理。、

- 函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。
- 函数并不是原始值，而是一种特殊的对象。也就是说，函数可以拥有属性。
- 在函数中声明的变量在整个函数体内都是可见的（包括在嵌套函数中）。在函数体外是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的。

## Day13
- 嵌套的函数不会将作用域内的私有成员赋值一份，也不会对所绑定的变量生成静态快照。
- 函数是值，对函数执行typeof运算会返回字符串“function”，但是函数是JavaScript中的特殊对象。因为他们是对象，也可以拥有属性和方法。
- 每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称为“原型对象”。每一个函数都包含不同的原型对象。

## Day14
- 高阶函数：就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新函数。

----------

- array.every(callback[, thisObject]);

**下面是参数的详细信息：**

1. callback : 函数用来测试每个元素
2. thisObject : 对象作为该执行回调时使用

----------


- 数组的map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。
- call()方法和apply()方法看做是某个对象的方法，通过调用方法的形式的来简介调用函数
> call()方法使用方法自有的实参列表作为函数的实参，apply()方法则要求以数组的形式传入参数。

    //f函数自有的实参列表f(x,y)
    f.call(o,1,2)
    f.apply(o,[1,2])

- 在JavaScript中，类的实现是基于其原型继承机制的，如果两个对象继承自同一个原型，往往意味着它们是由同一个构造函数创建并初始化的。
- JavaScript中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。
- 通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象。
- 任何类的方法都可以通过this的这种基本用法来读取对象的属性
- 使用关键字new来调用构造函数会自动创建一个新对象，因此构造函数本身只需要初始化这个新对象的状态即可。
- 调用构造函数的一个重要特征是，构造函数的prototype属性被用做新对象的原型。这就意味着通过同一个构造函数创建的所有对象都继承自相同一个对象，因此它们都是同一个类的成员。

## Day15
- 从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写，而普通的函数和方法都是首字母小写。
- 构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个心对象。
- 构造函数对象，任何添加到构造函数对象中的属性都是类字段和类方法。（如果属性值是函数的话就是类方法）。
- 原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用。
- 实例对象，类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。

----------
#### 在JavaScript中定义类的步骤 ####
1. 先定义一个构造函数，并设置初始化新对象的类属性。
2. 给构造函数的prototype对象定义实例的方法。
3. 给构造函数定义类字段和类属性


----------
- JavaScript私有属性可以使用闭包里的局部变量来模拟。
- JavaScript中基于原型的继承机制是动态的，如果创建对象之后原型的属性发生改变，也会影响到继承的这个原型的所有实例对象。
- instanceof 左操作数是待检测其类的对象，右操作数是定义类的构造函数。
> 尽管instanceof运算符的右操作数是构造函数，但计算过程实际上是检测了对象的继承关系，而不是检测创建对象的构造函数。
