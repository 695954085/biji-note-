### 2016.12.5 

- $thisNode以及$attchNode的区别：

		$thisNode是这个控件的最外层节点，例如控件来说，$thisNode会最后会appendTo到其所
		在最近的父容器的$attchNode里面。所以说，它们的功能是不一致的，一个是element的最外
		层，一个是容器的装载元素层。

- 扩展点,为什么不直接用Eclipse的扩展点：

		因为需要多平台实现，所以在android端的时候，手机不能使用Eclipse的扩展点机制，因此
		代码，抽出了一套接口，分别实现这套扩展点接口。

- preference.properities等配置文件什么时候会读取：详情可以看PreferenceServer PreferenceClient 读取文件，保存进入了properity

### 12/17/2016 9:21:43 PM

- abs.properities文件的读取

		大概是在cn.com.agree.ab.a4.server.plugin.xml中的
		point="org.eclipse.core.runtime.products"之后配置的
		
	    <extension
          id="product"
          point="org.eclipse.core.runtime.products">
        <product
            application="cn.com.agree.ab.a4.server.app"
            name="AB Server">
           <property
               name="preferenceCustomization"
               value="platform:config/abs.properties"/>
           <property
                 name="appName"
                 value="AB Server">
           </property>
        </product>
      </extension>

>其中，platform：config 可以获取server的configuration目录下的路径
>
>abs.properties默认被Eclipse加载到DefaultScope
	

### 12/20/2016 3:15:21 PM .

		IMission mission = createDomainPanelMission(IUIEventConstants.ON_FINISH);
		getHost().getDomainPanel().queueTaskPack(
				new MissionTaskPack(getHost().getDomainPanel(),
						mission), QueueType.MAJOR);

		IMission blurMission = curruntFocusedController
				.createDomainPanelMission(IUIEventConstants.ON_BLUR);
		blurMission.execute(new Callback<ProcessResult>(
				new IExceptionHandler() {
					public void handleException(Throwable t) {
						fail(t);
					}
				}) {
			public void call(ProcessResult t) {
				if (t.getThrowable() != null) {
					fail(t.getThrowable());
				}
			}
		});

这是事件端。 区别

### 12/21/2016 2:36:45 PM 

* 要知道org.eclipse.core.runtime.applications以及org.eclipse.core.runtime.products的区别

- JMX介绍
	1.  [http://blog.csdn.net/arjick/article/details/6268376](http://blog.csdn.net/arjick/article/details/6268376 "利用JMX来监控大部分java对象")

	2. JMX(Java Management Extensions,即Java管理扩展)是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议。灵活的开发无缝集成的系统、网络和服务管理应用。
	
	3. 实际上来说，我们可以用jmx来监控一些java应用的运行情况，还有自己写的一些服务类的应用。
	
	
- abs与abc的PreferencesServiceFactory是不一样。 

- Mina相关知识 可以参照[http://www.cnblogs.com/xuekyo/archive/2013/03/06/2945826.html](http://www.cnblogs.com/xuekyo/archive/2013/03/06/2945826.html)
	1. MinaServerMQChannel与MinaClientMQChannel的区别
	2. 搞懂cell与cellunit
	

### 12/22/2016 2:09:28 PM 

- GroupView的refresh(String key),这个refresh方法的触发？
	1. UiModel
		
		1. UiModel中的PropertyChangeSupport全局变量,支持PropertyChangeListeners[http://zhangjunhd.blog.51cto.com/113473/36838/](http://zhangjunhd.blog.51cto.com/113473/36838/)
		2. 使用这个类管理监听器的好处是，它是线程安全的。如果使用一个循环体来set Bean的属性，则这个类可以保证所有监听器执行触发事件的有序。

	2. Controller.propertyChange
		1. 当某个控件的属性值发生改变的时候触发。

###12/24/2016 1:26:27 PM 

- PrerequisiteManager类的load方法

	1. initThreadPool，初始化线程池
	2. loadJob() 方法加载所有的cn.com.agree.ab.a4.pub.prerequisite.run扩展点进入内存中。
	3. 遍历runnableMap，在线程池中threadPool中执行任务<br>线程相关知识可以参考[http://www.cnblogs.com/wanqieddy/p/3853863.html](http://www.cnblogs.com/wanqieddy/p/3853863.html)

			threadPool.submit(new StartJob(subMonitor, name))
			Callable任务有返回值，并且，Callable的call方法，返回一个<T>，是表示任务等待完成的Future。


- WebPrerequisite
	
	1. start方法中，它初始化了所有关于jetty的servlet，并把它们丢进去了ThreadPool中。


### 12/26/2016 1:17:23 PM 

- Mina与jetty的作用分析
	
	1. Mina的作用是：负责abs与abc之间的通信。 相关的协议是什么，待学习！
	2.关于Mina的相关配置，可以在abs.properties,以及abs_share.properties. 
	3. jetty的作用是：负责把文件从服务器中，下载到本地。 
		> 例如是 abf4a，更新插件之类的。

- 焦点跳转
	1. DirectedFocusTask - getFocusTarget()
	2. DomainPanel run()
	3. DomainPanel updateViewFocus()
	4. FocusTaskPack new Runnable(){}


- 操作服务器知识
	1. IP：38.63.131.251 fcabs fcabs
	2. configuration，perferenceServer，以及工程workspace，可以再本地重现服务器。
	3. #通讯端口 cn.com.agree.ab.a4.pub.communication.mina/port=50001


12/27/2016 5:16:54 PM 

- Linux命令
	1. tar -cvf FCBank.tar FCBank 打压缩包
	2. ls cd pwd


- 有关LFC的读取，涉及一下几个相关类
	1. LFCProcessDefinitionAdapter
	2. AbstractLFCProcessDefinitionAdapter
	3. IExperssion
	4. 这几个相关类，讲述了如何走一个逻辑

- Mvel 表达式学习
	1. 相关的学习资料在hello1插件中。
	
- xPath 表达式

- 部署插件问题
	1. export -> Plug-in Development -> Deployable plug-ins and fragments.
	2. 注意勾选源码

- 端口占用问题
	1. 输入netstat -ano，列出了所有端口的情况。 在列表中我们观察被占用的端口。
	2. 查看被占用端口的pid，输入命令netstat -aon|findstr “49157” ，就可查看pid
	3. 输入tasklist|findstr “2720” 知道哪个进程或者程序占用了端口。

- cn.com.apache.poi 插件的更新
	- 方法就是上官网下载最新版的jar包，然后解压，把里面的class文件，复制进去。
	- poi插件导出的时候，不需要勾选源码，且选择Generate source bundles，就不会出现log error

### 12/29/2016 10:32:00 AM 

- 解析LFC 
	1. AbstractLFCProcessDefinitionAdapter 
	    1. LogicletRegistry 
			1. 专门解析 cn.com.agree.ab.a4.pub.engine/logiclet扩展点。
			2. 保存进入到instanceMap内存中。
			3. ILogiclet logiclet = Context.getCurrent().get(LogicletRegistry.class).getInstance(name);
		2. 获取了LFC其中的逻辑组件 就是 logiclet
	2. AbstractExtensionLogiclet
	3. ExecuteCommandLogiclet
		1. 构建一个Command  Command command = new Command();
		2. Context.getCurrent().get(ICommandExecutor.class) 得到 CommandHandlerRegistry类
		3. CommandHandlerRegistry.execute方法
		4. 通过Command的Name值获取 ICommandHandler ， 因为是通过读取cn.com.agree.ab.a4.client.gui.adore/commandHandler扩展点
		5.  
	4. CommandHandlerRegistry
	5. ControllerCallMethod implements ICommandHandler
		1. CommandHandlerRegistry中执行 call方法
		2. call方法中执行 handler.handleCommand(command, callback);


### 1/5/2017 10:22:17 AM 

- 更新插件的方法
	1. 首先把昨天到今天早上的所有更新都找出来 例如 今天是2017/1/5的插件。 则需要把2017/1/4 ~ 2017/1/5 的所有更新都打jar包
	2. ts 文件需要编译
	2. 把export好的jar包，放进history目录下， 记录好 version.txt 文件
	3. 把更新的jar包，区别客户端以及服务器端
	4. 服务端有更新就需要重启服务器 sh shutdown.sh sh startup.sh
	5. 如果不能关机或者重启，就需要强行杀死进程。
		> 如何杀死进程，后续再看看，还有是否启动了服务器，就可以看看端口是否被占用了。
	6. Linux 端口是否被占用的问题： netstat -ant | grep 50010 查看50010的端口使用情况
	7. 查看进程 ps -ef | grep XX(程序名称) 找到pid
	8. kill -9 xx（进程的pid号）



- CacheCommandLogiclet以及ExecuteCommandLogiclet分析




### 1/6/2017 9:41:20 AM 

- 新建组件CacheShelfData，InitShelfFromCahce
	- 有以下几点需要注意：
		1. 泛型的warning一定要去除。
		2. ConCurrentHashMap的问题。支持多线程读写。
		3. CommandHandler出现callback.handleException的时候，最后return;

- 小工具的Bean的问题
	- ui文件id映射新id时，生成txt文件记录，旧id以及新id的关系
	  	1. 我直接在Bean文件上写成了ParseUiUtil.contentBean.addId(oldId, newId);
	  	2. 但是这样写很冗余，因为如果以后不是ui文件，是广发abf文件，就要再增加。所以很傻逼
	  	3. 之后修改成为以下代码


	<pre>
	// 找到父亲
	public ContentBean findContentBean() {
		if (this.parent == null)
			return null;
		if (this.parent instanceof ContentBean) {
			return (ContentBean) this.parent;
		}
		return this.parent.findContentBean();
	}
	</pre>
				
- UpdateValueStrategy dm <-> uimodel 互转 
	- Feature层
	- 双向数据绑定


### 1/7/2017 10:24:25 AM 

- Plug-in Dependencies 
	- Show Callees 这个插件依赖什么插件
	- Show Callers 这个插件被什么插件依赖


- Eclipse的条件断点问题
	- BreakPoint Porperities
	- 如果是要判断字符串是否相等时，注意以下几点：
		1. Line Breakpoint写成这样
		
				"text_NoPrintNum".equals(oldId)
		2. Java代码中，需要为oldId变量设置初始。
			
				String oldId = "";
				oldId = bean.getId();

		3. 且断点最好是断在上面两行代码之后。


- ABIDE的LFC的SetParameter逻辑组件的使用
	- 使用代码创建一个Map的方法
	
			java.util.Map map1 = new java.util.HashMap();
			map1.put("SUPERNO","5501");
			map1.put("TRANPATH","/FCBank/trade/Trade/SA/T20601/T20601.tad");
			map1.put("TRANCODE1","20601");
			map1.put("TRANNAME","个人开户");
			map1.put("TRANCODE","20601");
			map1.put("TRANNO","1");
			return map1;

### 1/9/2017 11:05:04 AM 

- 当技术组件(CommandHandler或者Logiclet) 
	- callback.handlerException的时候，界面会出现PanelMessageBox
	- 最后会调取了BusyPhase.displayErrorDialog方法

- DomainPanel uiBuildModel 为每一个Bean都创建一个UiModel文件
	- GuiView initFeatureRegistry 
		- 加载扩展点cn.com.agree.ab.a4.client.gui.adore.feature
			- featureRegistry.put(key, featureObj); 
	- start方法开始

- TextFeature createPolicy方法分析
	- super.createPolicy
		- list.add(new FocusPolicy())
	- Controller.createPolicies();
	- AbstractController.installPolicy()方法 里面 policy.activate();
	- 首先分析NormalModifyPolicy类，继承AbstractModifyPolicy，创建NormalModifyPolicy类时候，
	- AbstractModifyPolicy.activate方法，调用到Widget的addListener方法
	- WidgetActionPerformer.perform方法 调用widget.handleEvent(event);方法
	- EventDispatch.onMessage,调用以下代码
	
			  case WIDGET:
                JSONObject attrs = obj.getJSONObject("attributes");
                performer.perform(display, attrs);
                break;
	- 以上就是Policy，以及addListener，IEventListener的执行过程

- 要学习lr/lrt哦！





		
		