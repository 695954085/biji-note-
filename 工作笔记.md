### 2016.12.5 

- $thisNode以及$attchNode的区别：

		$thisNode是这个控件的最外层节点，例如控件来说，$thisNode会最后会appendTo到其所
		在最近的父容器的$attchNode里面。所以说，它们的功能是不一致的，一个是element的最外
		层，一个是容器的装载元素层。

- 扩展点,为什么不直接用Eclipse的扩展点：

		因为需要多平台实现，所以在android端的时候，手机不能使用Eclipse的扩展点机制，因此
		代码，抽出了一套接口，分别实现这套扩展点接口。

- preference.properities等配置文件什么时候会读取：详情可以看PreferenceServer PreferenceClient 读取文件，保存进入了properity

### 12/17/2016 9:21:43 PM

- abs.properities文件的读取

		大概是在cn.com.agree.ab.a4.server.plugin.xml中的
		point="org.eclipse.core.runtime.products"之后配置的
		
	    <extension
          id="product"
          point="org.eclipse.core.runtime.products">
        <product
            application="cn.com.agree.ab.a4.server.app"
            name="AB Server">
           <property
               name="preferenceCustomization"
               value="platform:config/abs.properties"/>
           <property
                 name="appName"
                 value="AB Server">
           </property>
        </product>
      </extension>

>其中，platform：config 可以获取server的configuration目录下的路径
>
>abs.properties默认被Eclipse加载到DefaultScope
	

### 12/20/2016 3:15:21 PM .

		IMission mission = createDomainPanelMission(IUIEventConstants.ON_FINISH);
		getHost().getDomainPanel().queueTaskPack(
				new MissionTaskPack(getHost().getDomainPanel(),
						mission), QueueType.MAJOR);

		IMission blurMission = curruntFocusedController
				.createDomainPanelMission(IUIEventConstants.ON_BLUR);
		blurMission.execute(new Callback<ProcessResult>(
				new IExceptionHandler() {
					public void handleException(Throwable t) {
						fail(t);
					}
				}) {
			public void call(ProcessResult t) {
				if (t.getThrowable() != null) {
					fail(t.getThrowable());
				}
			}
		});

这是事件端。 区别

### 12/21/2016 2:36:45 PM 

* 要知道org.eclipse.core.runtime.applications以及org.eclipse.core.runtime.products的区别

- JMX介绍
	1.  [http://blog.csdn.net/arjick/article/details/6268376](http://blog.csdn.net/arjick/article/details/6268376 "利用JMX来监控大部分java对象")

	2. JMX(Java Management Extensions,即Java管理扩展)是一个为应用程序、设备、系统等植入管理功能的框架。JMX可以跨越一系列异构操作系统平台、系统体系结构和网络传输协议。灵活的开发无缝集成的系统、网络和服务管理应用。
	
	3. 实际上来说，我们可以用jmx来监控一些java应用的运行情况，还有自己写的一些服务类的应用。
	
	
- abs与abc的PreferencesServiceFactory是不一样。 

- Mina相关知识 可以参照[http://www.cnblogs.com/xuekyo/archive/2013/03/06/2945826.html](http://www.cnblogs.com/xuekyo/archive/2013/03/06/2945826.html)
	1. MinaServerMQChannel与MinaClientMQChannel的区别
	2. 搞懂cell与cellunit
	

### 12/22/2016 2:09:28 PM 

- GroupView的refresh(String key),这个refresh方法的触发？
	1. UiModel
		
		1. UiModel中的PropertyChangeSupport全局变量,支持PropertyChangeListeners[http://zhangjunhd.blog.51cto.com/113473/36838/](http://zhangjunhd.blog.51cto.com/113473/36838/)
		2. 使用这个类管理监听器的好处是，它是线程安全的。如果使用一个循环体来set Bean的属性，则这个类可以保证所有监听器执行触发事件的有序。

	2. Controller.propertyChange
		1. 当某个控件的属性值发生改变的时候触发。

###12/24/2016 1:26:27 PM 

- PrerequisiteManager类的load方法

	1. initThreadPool，初始化线程池
	2. loadJob() 方法加载所有的cn.com.agree.ab.a4.pub.prerequisite.run扩展点进入内存中。
	3. 遍历runnableMap，在线程池中threadPool中执行任务<br>线程相关知识可以参考[http://www.cnblogs.com/wanqieddy/p/3853863.html](http://www.cnblogs.com/wanqieddy/p/3853863.html)

			threadPool.submit(new StartJob(subMonitor, name))
			Callable任务有返回值，并且，Callable的call方法，返回一个<T>，是表示任务等待完成的Future。


- WebPrerequisite
	
	1. start方法中，它初始化了所有关于jetty的servlet，并把它们丢进去了ThreadPool中。


### 12/26/2016 1:17:23 PM 

- Mina与jetty的作用分析
	
	1. Mina的作用是：负责abs与abc之间的通信。 相关的协议是什么，待学习！
	2.关于Mina的相关配置，可以在abs.properties,以及abs_share.properties. 
	3. jetty的作用是：负责把文件从服务器中，下载到本地。 
		> 例如是 abf4a，更新插件之类的。

- 焦点跳转
	1. DirectedFocusTask - getFocusTarget()
	2. DomainPanel run()
	3. DomainPanel updateViewFocus()
	4. FocusTaskPack new Runnable(){}


- 操作服务器知识
	1. IP：38.63.131.251 fcabs fcabs
	2. configuration，perferenceServer，以及工程workspace，可以再本地重现服务器。
	3. #通讯端口 cn.com.agree.ab.a4.pub.communication.mina/port=50001


12/27/2016 5:16:54 PM 

- Linux命令
	1. tar -cvf FCBank.tar FCBank 打压缩包
	2. ls cd pwd
	3. tar -xvf FCBank.tar 解压压缩包


- 有关LFC的读取，涉及一下几个相关类
	1. LFCProcessDefinitionAdapter
	2. 
	3. FCProcessDefinitionAdapter
	3. IExperssion
	4. 这几个相关类，讲述了如何走一个逻辑

- Mvel 表达式学习
	1. 相关的学习资料在hello1插件中。
	
- xPath 表达式

- 部署插件问题
	1. export -> Plug-in Development -> Deployable plug-ins and fragments.
	2. 注意勾选源码

- 端口占用问题
	1. 输入netstat -ano，列出了所有端口的情况。 在列表中我们观察被占用的端口。
	2. 查看被占用端口的pid，输入命令netstat -aon|findstr “49157” ，就可查看pid
	3. 输入tasklist|findstr “2720” 知道哪个进程或者程序占用了端口。（这个是Window）

- cn.com.apache.poi 插件的更新
	- 利用Eclipse new Plug-in from Jar的选项。
	- poi插件导出的时候，不需要勾选源码，且选择Generate source bundles，就不会出现log error

### 12/29/2016 10:32:00 AM 

- 解析LFC 
	1. AbstractLFCProcessDefinitionAdapter 
	    1. LogicletRegistry 
			1. 专门解析 cn.com.agree.ab.a4.pub.engine/logiclet扩展点。
			2. 保存进入到instanceMap内存中。
			3. ILogiclet logiclet = Context.getCurrent().get(LogicletRegistry.class).getInstance(name);
		2. 获取了LFC其中的逻辑组件 就是 logiclet
	2. AbstractExtensionLogiclet
	3. ExecuteCommandLogiclet
		1. 构建一个Command  Command command = new Command();
		2. Context.getCurrent().get(ICommandExecutor.class) 得到 CommandHandlerRegistry类
		3. CommandHandlerRegistry.execute方法
		4. 通过Command的Name值获取 ICommandHandler ， 因为是通过读取cn.com.agree.ab.a4.client.gui.adore/commandHandler扩展点
		5.  
	4. CommandHandlerRegistry
	5. ControllerCallMethod implements ICommandHandler
		1. CommandHandlerRegistry中执行 call方法
		2. call方法中执行 handler.handleCommand(command, callback);


### 1/5/2017 10:22:17 AM 

- 更新插件的方法
	1. 首先把昨天到今天早上的所有更新都找出来 例如 今天是2017/1/5的插件。 则需要把2017/1/4 ~ 2017/1/5 的所有更新都打jar包
	2. ts 文件需要编译
	2. 把export好的jar包，放进history目录下， 记录好 version.txt 文件
	3. 把更新的jar包，区别客户端以及服务器端
	4. 服务端有更新就需要重启服务器 sh shutdown.sh sh startup.sh
	5. 如果不能关机或者重启，就需要强行杀死进程。
		> 如何杀死进程，后续再看看，还有是否启动了服务器，就可以看看端口是否被占用了。
	6. Linux 端口是否被占用的问题： netstat -ant | grep 50010 查看50010的端口使用情况
	7. 查看进程 ps -ef | grep XX(程序名称) 找到pid
	8. kill -9 xx（进程的pid号）



- CacheCommandLogiclet以及ExecuteCommandLogiclet分析




### 1/6/2017 9:41:20 AM 

- 新建组件CacheShelfData，InitShelfFromCahce
	- 有以下几点需要注意：
		1. 泛型的warning一定要去除。
		2. ConCurrentHashMap的问题。支持多线程读写。
		3. CommandHandler出现callback.handleException的时候，最后return;

- 小工具的Bean的问题
	- ui文件id映射新id时，生成txt文件记录，旧id以及新id的关系
	  	1. 我直接在Bean文件上写成了ParseUiUtil.contentBean.addId(oldId, newId);
	  	2. 但是这样写很冗余，因为如果以后不是ui文件，是广发abf文件，就要再增加。所以很傻逼
	  	3. 之后修改成为以下代码


	<pre>
	// 找到父亲
	public ContentBean findContentBean() {
		if(this instanceof ContentBean){
			return (ContentBean)this;
		}
		if (this.parent == null)
			return null;
		if (this.parent instanceof ContentBean) {
			return (ContentBean) this.parent;
		}
		return this.parent.findContentBean();
	}
	</pre>
				
- UpdateValueStrategy dm <-> uimodel 互转 
	- Feature层
	- 双向数据绑定


### 1/7/2017 10:24:25 AM 

- Plug-in Dependencies 
	- Show Callees 这个插件依赖什么插件
	- Show Callers 这个插件被什么插件依赖


- Eclipse的条件断点问题
	- BreakPoint Porperities
	- 如果是要判断字符串是否相等时，注意以下几点：
		1. Line Breakpoint写成这样
		
				"text_NoPrintNum".equals(oldId)
		2. Java代码中，需要为oldId变量设置初始。
			
				String oldId = "";
				oldId = bean.getId();

		3. 且断点最好是断在上面两行代码之后。


- ABIDE的LFC的SetParameter逻辑组件的使用
	- 使用代码创建一个Map的方法
	
			java.util.Map map1 = new java.util.HashMap();
			map1.put("SUPERNO","5501");
			map1.put("TRANPATH","/FCBank/trade/Trade/SA/T20601/T20601.tad");
			map1.put("TRANCODE1","20601");
			map1.put("TRANNAME","个人开户");
			map1.put("TRANCODE","20601");
			map1.put("TRANNO","1");
			return map1;

### 1/9/2017 11:05:04 AM 

- 当技术组件(CommandHandler或者Logiclet) 
	- callback.handlerException的时候，界面会出现PanelMessageBox
	- 最后会调取了BusyPhase.displayErrorDialog方法

- DomainPanel uiBuildModel 为每一个Bean都创建一个UiModel文件
	- GuiView initFeatureRegistry 
		- 加载扩展点cn.com.agree.ab.a4.client.gui.adore.feature
			- featureRegistry.put(key, featureObj); 
	- start方法开始

- TextFeature createPolicy方法分析
	- super.createPolicy
		- list.add(new FocusPolicy())
	- Controller.createPolicies();
	- AbstractController.installPolicy()方法 里面 policy.activate();
	- 首先分析NormalModifyPolicy类，继承AbstractModifyPolicy，创建NormalModifyPolicy类时候，
	- AbstractModifyPolicy.activate方法，调用到Widget的addListener方法
	- WidgetActionPerformer.perform方法 调用widget.handleEvent(event);方法
	- EventDispatch.onMessage,调用以下代码
	
			  case WIDGET:
                JSONObject attrs = obj.getJSONObject("attributes");
                performer.perform(display, attrs);
                break;
	- 以上就是Policy，以及addListener，IEventListener的执行过程

- 要学习lr/lrt哦！


### 1/10/2017 10:40:03 AM 

- Controller.bindValues方法作用 绑定 UiModel与DataModel 
- 

- PreferenceClient 实现了预加载接口IPrerequisite，客户端启动。
	- start方法
		- 首先注册一个cellUnit ，创建CellUnit类，关联到CommunicationManager类。
		- cellUnit.register。最终调用到Cell的registerUnit方法。
		- requestPreference();加载请求信息
		- 最终调用了unit.sendMap(unit.getCell().getParentOid() + "/preferenceServer"+ CellUnit.UNIT_NAME_AMEBA_SUFFIX, map); 就可以发送数据了。
		- 最终会调用 cell类中的方法中的 vmChannel.send。 找到相应的 MinaClientMQChannel。

- PreferenceServer 同样是实现了IPrerequisite接口。
	- start方法
		- 注册一个cellUnit

- MinaServerMQChannel 创建这个类的时候。
	- 执行loadPreference方法，prefPortStr = PreferencesServiceFactory.getService().getString("cn.com.agree.ab.a4.pub.communication.mina", "port", prefPortStr); 获取了abs.properities配置文件的
	- start()方法。
		- acceptor = new SocketAcceptor(numCpu, acceptorThreadPool); 
		- acceptor.bind(new InetSocketAddress(port), handler, cfg); 监听50001端口
	- send(Properties props, Map map) 方法，发送数据作用。
		- 但是什么时候被调用。现在查看中。
	- IoHandler 负责数据的接收。 数据从MinaClientMQChannel中发送过来的，数据接收后。
		- 数据接收后，调用 messageListener.onMessage(m);方法 
		- 这个MessageListener被cell类实现。 MinaServerMQChannel后与Server端的Cell创建。Cell创建后，读取getMQChannelFactory方法中的mqChannelFactory扩展点。创建MinaServerMQChannel类。创建完本类后，为此类setMessageListener。
	- CommunicationManager.getDefault().getCell().start(); // ABServerApplication
	

- GuiView，从哪里获取交易资源文件	


- PreferencesServiceFactory
	- 保存数据进入Service中是，是通过1.IABPreferences defaultPreferences = service.getDefaultPreferences(); 2.defaultPreferences.put(k, v);
	- 读取数据，则通过PreferencesServiceFactory.getService().getString("cn.com.agree.ab.preference","include", "");



- Debug Configurations 中
	- abc_adore.product文件指定了 Product Definition 
	- gui.adore 指定了 cn.com.agree.ab.a4.client.product
	- abc_adore.product中的workspace指定路径为${workspace_loc:cn.com.agree.ab.a4.client.gui.adore/ROOT/workspace}
	- abc_adore.product中指定的config为${workspace_loc:cn.com.agree.ab.a4.client.gui.adore/ROOT/configuration}
	- 所以在abc_adore.product 指定了a4.client.product，a4.client.product在启动时，加载的路径是gui.adore的workspace，和configuration目录。


### 1/11/2017 9:07:18 AM 
- Debug Configurations 
	- abc_adore.product  更新，清理缓存的策略
		- Main 选择Clear按钮 
		- Arguments Program arguments 加上-refresh

- 加载perference.properities的步骤
	- ABServerApplication程序开始 start方法
	- Status[] status = PrerequisiteManager.getDefault().load(); 记载预加载文件
	- 启动了PreferenceServer类的start方法 handlerMap方法，加载配置文件。
	- PreferenceClient handlerMap方法接收到配置文件。
	
- ABClientApplication启动过程中
	- start方法启动
	- loadStatus = PrerequisiteManager.getDefault().load();
	- PreferenceClient 请求服务器 
	- PreferenceServer 下发配置
	- PreferenceClient 的 handlerMap方法接收服务器下发的配置。
	- int returnCode = PlatformUI.createAndRunWorkbench(display, advisor); // 启动界面 
	- 启动Win32插件 执行ABCViewPart类。
	- 创建GuiView类,执行了createPartControl()方法
	- GuiView.createTrade(String tadPath, boolean openAgain)方法 从服务器下发的配置中得到tadPath
	- Domain.start(Map<String, Object> importData, Callback<ProcessResult> finishCallback)
	- TradeAssemblyDefine tad = context.get(ResourceDocumentTable.class).getDocument(tadPath, TradeAssemblyDefine.class); 
	- File file = ResourceManager.getDefault().getResourceFile(path);
	- downloadFile(path)； 
	- URL url = resourceClient.getResourceUrl(path); 
		> http://127.0.0.1:50002/servlets/downloadResource/_test/trade/test25/Test25.tad
		> 请求服务器中的DownloadResourceServlet
		
- ResourceManager 监控资源类文件 引用到了GRM(GlobalResoueceManager)的概念
	- getResourceFile


- pub.engine LogicletRegistry类的加载
	- EnginePlugin的加载，会执行LogicletRegistry的loadLogiclets()方法。
	- 当LFC中执行到server.lfc 逻辑组件的时候
	- abc中找不到注册的Logiclet，抛出异常
	- ProcessInstanceThreadSegment  Context.getCurrent().get(IProcessRemoting.class).launch(this);
	- TradeClient.launch(ProcessInstanceThreadSegment segment)；
	- cellUnit发送消息到TradeServer



- 客户端的GRM类的创建
	- cn.com.agree.ab.a4.client.resource插件
		- ResourceClientPrerequisite预加载，执行start方法
		- ResourceManager.getDefault().init();
		- ResourceManager.getDefault().initFileMonitor();
		- GlobalResourceMap newGRM = new GlobalResourceMap(resourceClient != null);
		- GlobalResourceMap.initByLoading();

- 服务器端也会创建GRM 
- FileMonitor插件

### 1/12/2017 11:02:18 AM 

- DefaultExpressionEngine
	- varMap() 该LFC
	- 虽然不同客户端执行相同的交易，但是VarMap存储的数据是会根据不同操作而不同。 


- LFC执行的流程
	1. 点击按钮，执行LFC，那么平台就会走一个流程 执行FlowMission.execute
	2. ProcessInstanceThreadSegment pits = pif.pitsByGettingPIT(currentTask.getRealm(), flowName); 
	3. pit.openSegment(definitionPath);
	4. new ProcessInstanceThreadSegment(segmentIdSeed.incrementAndGet(), this, definitionPath);
	5. ProcessInstanceThreadSegment中全局变量为  private VarMap inArgMap = new VarMap();
	6. 就是说，平台每次执行一次流程，都会new出一个新的pits。一个新的pits就有一个新的VarMap。


- ABIDE的同步平台组件功能
	1. 就是调起QueryLogicletInfo类。ILogiclet
	2. 然后通过LogicletRegistry得到所有组件信息。

- DataBindingContext
	1. 数据绑定技术，是用来解决模型和UI元素之间重复的赋值和取值的繁琐工作，使用数据绑定，初始化时做一次绑定，之后无需关心UI界面和模型的之间的赋值和取值的操作。

#### 注意：再写CommandHandler以及ILogiclet的时候，入参如果为null的时候，要注意这种情况的防范，以及方法的Exception要往上抛，使用callback.handlerException.


### 1/14/2017 11:15:22 AM 

- ButtonFeature
	- 双向数据绑定
	 <pre>
		componentBinding.createAttributeBinding().data(dataModel,DataModelKeys.toUIComponentAttribute(controller
                    .getDomainPanel().getTargetId(), uiModel
                    .getId(), IComponentKeys.TEXT))
           .ui(uiModel, IComponentKeys.TEXT).commit();
	 </pre>
	- 以上代码解析：data方法与ui方法同时使用，就是把dataModel中的DataModelKeys.toUIComponentAttribute(controller.getDomainPanel().getTargetId(), uiModel.getId(), IComponentKeys.TEXT)的key值，与uiModel中的IComponentKeys.TEXT的key值，相互绑定。

	
- Realm.runWithDefault(Realm realm, Runnable runnable) 
	-Realm 中文翻译：领域，范围？

- SWT中要想创建一个窗口，至少要用到两个类：Display和Shell。Display负责处理所有SWT窗口小部件和操作系统之间的交互。比如我们可以通过Display的方法来查询操作系统:哪个控件获取了焦点，当前打开了哪些窗口等等。简单的说，它的功能在于实现了窗口的管理。与Display不同，Shell的实例为我们提供了真正可见的窗口，该窗口一半作为主窗口使用，我们可以在此放置其他窗口部件。需要注意的是，这些窗口是由桌面（MS Window）或窗口管理程序（Unix或Linux系统）来管理。Shell是实例可以直接从Display创建。也可以从父代Shell创建。
- Shell需要响应一些事件，其中某些是由操作系统引起的，另外一些是由用户引起的。如用户点击了最大化按钮以及关闭Shell创建的窗口等。事件循环一直监听这些事件，然后将这些事件转发给相应的处理程序，这是由Display类的readAndDispatch方法来完成的。这就意味着，你创建的每个Shell必须具有它自己的事件循环。如果创建的Shell没有事件循环，或者事件循环失效的话，它马上就会被除去。
一般情况下，事件循环会一直执行下去，直到Shell类的isDisposed方法返回值为true。

- a4.test解析
	- bindingContext.bindValue(uiModel.ui("text"), dataModel.data("data_text"));
	- DataBindingContext.bindValue(IObservableValue targetObservableValue, IObservableValue modelObservableValue)；
		- 首先从 modelObservableValue的doGetValue方法，得到值后，赋值为targetObservableValue的doSetValue方法。绑定完毕。
		- 其次，当dataModel的值发生改变，或者uiModel的值发生改变。都是相应的调用改变了值的IObervableValue的doGetValue方法，然后调用另一个IObservableValue的doSetValue方法。



- schedule() startSub() hook()


### 1/16/2017 9:44:56 AM 

- LogicRealmTask.schedule() 立即实行
- LogicRealmTask.startSub(Runnable then) 最后执行
- LogicRealmTask.hook(Runnable nextRunnable) 一步一步执行 兄弟任务



- 流程
	- GuiView.createTrade(String tadPath, boolean openAgain)
	- Domain.start(Map<String, Object> importData, Callback<ProcessResult> finishCallback)
		- Domain里面新建了一个DataModel 
	- TradeAssemblyDefine tad = context.get(ResourceDocumentTable.class).getDocument(tadPath, TradeAssemblyDefine.class);//获取tad
		- TADDocumentParser.parse("/_test/trade/ToolTipTest/ToolTipTest.tad", ResourceManager.getDefault().getResourceStream("/_test/trade/ToolTipTest/ToolTipTest.tad")) throws IOException
		-  解析tad中 TadDocumentParser 中的 
		-  DataNameCollection dnc = Context.getCurrent().get(ResourceDocumentTable.class).getDocument(path, DataNameCollection.class);
		-  加载了DNCDocumentParser.parse("/_test/trade/ToolTipTest/ToolTipTest.tad",ResourceManager.getDefault().getResourceStream("/_test/trade/ToolTipTest/ToolTipTest.tad"))；
			> Domain有自己的DataModel
		- Domain ADERegistry adeRegistry = context.get(ADERegistry.class);
		- ((IContextFunction) result).compute(this, name);
		- DataPrerequisite.start(IABProgressMonitor monitor) 预加载

- TradeAssemblyDefine <-> TADDocumentParser
- DataNameCollection <-> DNCDocumentParser
- MainProcessTemplate <-> MPTDocumentParser
- ProcessDefinition <-> ProcessDefinitionParser
- LogicFlowControl  <-> AbstractLFCDocumentParser
- AgreeBrowserFace <->  ABFDocumentParser

- ResourceManager init()
	-  ResourceManager.getDefault().initResourceDocumentTable()。
	-  Context.getBase().set(ResourceDocumentTable.class,new ResourceDocumentTable());
	-  IABExtensionPoint point = ExtensionRegistryFactory.getRegistry().getExtensionPoint(ResourceManager.QUALIFIER, "documentParser");

### 1/17/2017 7:40:55 PM 

- LogicRealm LogicRealmTask
	- mainTask.schedule()
	- realm.exec(this)
	- asyncExec(runnable)
	- asyncExec(wrapTask(r))
	- tryToStart();
	- runTaskQueue();
	- boolean sync = runDirectly(task);
		- task.run(); 运行currentTask任务
		- task = currentTask.getNext(); 上一个currentTask运行完后，可能出现新的currentTask


### 1/18/2017 3:39:43 PM 

- PITS(ProcessInstanceThreadSegment) --- 每个文件的执行为一个线段(segment), 如TAD，LFC，AUF都可视为一个PITS 。
- 每个交易都有一个根的lrt，只要把根lrt结束，根lrt衍生任务都结束。

- PITS的创建流程
	1. ProcessInstanceFactory pif = context.get(ProcessInstanceFactory.class);
	2. ProcessInstanceThreadSegment segment = pif.pitsByCreatingPI(context, tadPath);
		1. pi = new ProcessInstance(id, context, definitionPath);
		2. ProcessInstanceThread pit = pi.openThread();
		3. pit.openSegment(definitionPath);
	3. segment.start(inArgMap, wrapFinishCallback(finishCallback));


- processDefinitionAdapter
	- ProcessInstanceThreadSegment 
		- this.definition = Context.getCurrent().get(ResourceDocumentTable.class).getDocument(definitionPath, ProcessDefinition.class);
		- //创建的PITS的时候会定义definition 解析Tad等文件
		- tad <-> TADProcessDefinitionAdapter
		

- TADProcessDefinitionAdapter 作用就是解析MPT
	- tad.setMPT(Context.getCurrent().get(ResourceDocumentTable.class).getDocument(tad.getMPTPath(), MainProcessTemplate.class));

- MPTDocumentParser 生成 MainProcessTemplate对象
	- mpt.setStartNodeId(root.getAttribute("start")); 


- TADProcessDefinitionAdapter
	- public Runnable createNodeRunnable(Object definitionBean,final String nodeId)

- IProcessDefinitionAdapter
	- AbstractALRProcessDefinitionAdapter
	- AbstractLFCProcessDefinitionAdapter
	- AFTProcessDefinitionAdapter
	- AUFProcessDefinitionAdapter
	- CSDProcessDefinitionAdapter
	- TADProcessDefinitionAdapter


- DNCDocumentParser 用来解析文件的数据字典

- Parser文件只是用作解析文件作用
- ProcessDefinition 作用是PITS的执行流程



- TADProcessDefinitionAdapter
	- private void performUIStep(TradeAssemblyDefine tadBean,MainProcessTemplate mptBean, MPTStep step)
	- 这个方法进行了abf4a的解析
	- uiStepLogiclet.call(inArgMap,new NodeTaskCallback(LogicRealmTask.getCurrent()));  uiStepLogiclet = new UIStepLogiclet();
	- UIStepLogilet.call
		- callABF(inputParams, callback);
		- OpenPanel 
			- domain.openDomainPanel(parentDomainPanel, path, dataView, title, target, targetArgMap,null,laneData,MappingUtil.wrapCallbackToFinishDataMapping(callback, mapping,currentTask));
			- panel.start(dataView, callback);
			- abf = getContext().get(ResourceDocumentTable.class).getDocument(uiPath, AgreeBrowserFace.class);
			- 开始解析ABF4A
	- DomainPanel startUI(AgreeBrowserFace abf);
	- rootController.setDomainPanel(this);
		

- WidgetActionPerformer 处理Html端发送来的widget事件
	- perform(final AdoreDisplay display, final JSONObject attributes)
	
			String syncAttrName = attributes.getString(SYNC_ATTRNAME);
			if (syncAttrName != null) {
				try {
					Field f = getAdoreField(widget.getClass(), syncAttrName);
					if (f != null) {
						f.setAccessible(true);
						f.set(widget, attributes.get(syncAttrName));
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}

	- 这段代码例子 ，例如Text文本框里面的内容发生改变的时候。 js端发送以下消息

			EventHub.dispatchEvent(MessageType.WIDGET, {
                id: id,
                text: $(this).val(),
                evtType: Event.MODIFY,
                syncAttrName: "text"
            });

	- 所以以上会改变Text.java类中的text属性的内容。


- 一个Domain 一个DataModel
- 一个控件对应一个UiModel


- J	 Replace 全部替换字符 用法
	- 将字母\n替全部换成分号
	- r.replace(/\n/g, ";"); 
	- 结果：1;2;3; replace 的第一个参数可以是正则表达式，/g标识全文匹配。

### 2/6/2017 10:19:39 AM 

- log4j是什么。
	- Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器等。我们可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。我们可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。

- 日志记录器（Logger）的行为是分等级的。
	- 日志记录器（Logger）将只输出那些级别高于或等于它的级别的信息。如果没有设置日志记录器（Logger）的级别，那么它将会继承最近的祖先的级别。因此，如果在包com.foo.bar中创建一个日志记录器（Logger）并且没有设置级别，那它将会继承在包com.foo中创建的日志记录器（Logger）的级别。如果在com.foo中没有创建日志记录器（Logger）的话,那么在com.foo.bar中创建的日志记录器（Logger）将继承root 日志记录器（Logger）的级别，root日志记录器（Logger）经常被实例化而可用，它的级别为DEBUG。

- Logger.getLogger和LogFactory.getLog 区别
	- Logger来自log4j自己的包。如果用Logger.getLogger，需要一个log4j的jar包，用此方式你只能依靠log4j：
	- LogFactory来自common-logging包。如果用LogFactory.getLog，你可以用任何实现了通用日志接口的日志记录器替换log4j，而程序不受影响。apache的common-logging包是通用日志接口，通过这个中间层，你可以随便指定到底用哪个日志系统。增加系统的灵活性。若log4j它不存在, commons-logging 会另行选择其它的日志实现类。这样保证了程序中不一定要使用log4j这个日志文件了 。

- Hierarchy h = new Hierarchy(new RootLogger((Level) Level.DEBUG));
	- 上面的所有代码均完成两件事，第一件事就是构造一个ROOT的Logger对象，此对象作为所有logger对象的最上层，其它logger的相应属性均从这个对象进行继承或改写，就好像java里的继承一样，这个类是内定的，不能由配置文件直接指定，且root都是在最顶层的，其他logger均在此下，这样形成一个完整的logger树。下层可以引用上层，上层管理下层。    第二件事则是去寻找配置文件的地址信息，通过各种方法都寻找log4j.xml或log4j.properties文件，然后对文件进行解析。（在此处，通过properties文件进行解析）

- log4j.properities配置详解
	- Log4J的配置文件就是用来设置记录器的级别、存放器和布局的，它可接key=value格式的设置信息。通过配置，可以创建出Log4J的运行环境。

### 2/7/2017 11:07:51 AM 

- 调试技巧 Chrome
	- 有可能js中的某些方法被干掉了，就会导致整个页面刷不出来的问题。
	- 如何查找js中哪个类的哪个方法被干掉。就可以利用调试框，先断Composite的construct方法，进入VM，然后逐条往下断点。


### 2/9/2017 3:38:41 PM 

- FoucsTaskPack学习
	- PointedFoucsTaskPack,以及DirectedFocusTaskPack继承FoucsTaskPack。
	- 该任务包完成焦点转移任务。焦点的转移有两种方式，一种是定位转移，即确定转移目标的转移，例如鼠标点击，另一种是定向转移，即确定转移方向的转移，例如键盘操作。 这两种转移方式的实现分别为子类，cn.com.agree.ab.a4.client.gui.adore.task.PointedFocusTaskPack和cn.com.agree.ab.a4.client.gui.adore.task.DirectedFocusTaskPack
	- 首先分析定位移动PointedFocusTaskPack类


### 2/10/2017 10:43:15 AM 

- AbstractLFCDocumentParser 此类为解析LFC文件
- AbstractLFCProcessDefinitionAdapter 此类为运行LFC文件
	- performLogicletComponentElement(final LogicFlowControl bean,final String nodeId, final LogicletComponentElement ce) 此方法为解析某个Logiclet的入参出参，并解析。

- 在逻辑组件中就是Logiclet中，的入参以及出参，经常会出现dm() tadVarMap() varMap() inArgMap() outArgMap() 最终解析就是DefalutExpressionEngine中的相应的方法 获取相应的DataModel，varMap
- PropertyHandlerFactory.registerPropertyHandler(Class clazz, PropertyHandler propertyHandler, boolean recursive)。
	- 其中有public Object getProperty(String prop, Object ctx,VariableResolverFactory facotry)
	- public Object setProperty(String prop, Object ctx,VariableResolverFactory factory, Object value)
	- 这两个方法就是Mevl最终的解析。Class类型多样，其中有解析DataModel类，Map类，List类，Array类等等。

- EntriesUpdater.updateModelEntries(DomainPanel domainPanel, UIModel model, Element[] entries)
	- 方法解析，主要用于把Abf4a界面中的Entry信息，保存到uiModel中。


### 2/14/2017 10:00:20 AM 

- LogicRealm，LogicRealmTask 以及 AdoreDisplay.getCurrent().syncExec(final Runnable runnable) 之间的关系说明
	- 首先来分析什么是AdroeDisplay 
		- AdoreDisplay与AdoreThread以及CefAdoreBrowser，关系密切
		- AdoreDisplay是一个单例模式开发的类，初始化时由调用其init(IAdoreBrowser browser)方法。
		- AdoreDisplay的构造函数，创建了AdoreThread线程类
		- AdoreThread创建了一个死循环的线程，不断执行外部传来的任务

				taskQueue.add(task); //添加任务 83行
				task = taskQueue.take(); //执行任务 55行

		- CefAdoreBrowser的构造函数，在Win32插件中的ABCViePart类中执行（也就是swt窗口创建的时候调用）
			- 其构造就关于浏览器加载页面index.html的相关知识。
		- 为什么所有组件操作的AdoreDisplay.syncExecJs(String script, ExecutorEvent executorEvent)
			- “消息循环”，操作系统把用户界面上的每个操作都转化为对应的消息，加入消息队列。然后把消息转发给对应的应用程序（一半来说，就是活动窗口），应用程序根据自己的逻辑处理这些消息。如果应用程序根据自己的逻辑处理这些消息的时候，用了很长的时间，这个时候后续的消息无法及时得到处理。就会造成应用程序没有响应，也就是说无法及时得到处理，就会出现程序没有响应，也就是常说的“假死”状态。所以，应用程序如果处理某个事件需要较长的时间，需要把这个操作放到一个另外的线程中进行处理。
			- while循环一段就是处理消息循环的开始，也就是说，一个SWT程序的主线程，就是对应的所谓的UI线程。
			- SWT中非UI线程访问UI线程的情况，需要用Display类的syncExec(Runnable)或asyncExec(Runnable)两个方法来执行。
			- syncExec(runnable)方法的参数runnable对象实际上是会被放进UI线程中进行的。
			- syncExec和asyncExec方法的区别就是这两个方法一个会等待runnable执行完才返回，asyncExec方法则立即返回，UI线程会在有空闲的时候去执行runnable。
		- AdoreThread里面开启了一个Daemon线程。
			- java语言可以创建两种线程“用户线程”和“守护线程”
			- 用户线程：就是我们平常创建的普通线程
			- 守护线程：主要是用来服务用户线程
			- 当线程只剩下守护线程的时候，JVM就会退出，但是如果还有其他的任意一个用户线程还在，JVM就不会推出。
			- AdoreThread是一个守护线程，当只剩下守护线程，该线程就终结。
		- 但凡与组件相关的调用，就需要使用AdoreDisplay的asyncExec和syncExec方法。


- Context类分析
	- baseContext getBase() static
	- threadCurrent static
	- Context主要用于存放类的实例，ConcurrentMap<String, Object> localValues
	- Context类还可以创建baseContext的子类 ConcurrentHashMap<String, Context> childrenMap

### 2/15/2017 9:54:57 AM

- Picture表达式
	- "99" 代表文本框只能输入两位数。
	- 与"99"相同语义的表达方式是 2"9" , "9"代表的是数字，2代表是2位数。
	- -2"99"，-号则代表的是左对齐。 

- FocusPolicy类继承AbstractPolicy事件，在每个组件创建的时候都会创建到。
	
		list.add(new FocusPolicy()); //AbstractFeature类 104行

	- 点击某个组件(该组件现在没有光标)，会触发FoucsPolicy点击事件的focusListener

			domainPanel.queueTaskPack(new PointedFocusTaskPack(domainPanel,id), QueueType.IDLE); 

### 2/18/2017 3:13:18 PM 

- Log4j以及console信息的解析
	- log4j.properties为配置文件初始化好了log4j环境
	- PropertyConfigurator.configure("log4j.properties"); //配置log4j环境
	- Log4JLogFactory.initHierarchy(Bundle bundle) 
		- 首先加载common.logging包下的log4j.properties
		- 其次加载Configuration目录下的log4j.properties
		- 如果重复，后加载的option覆盖前option
	- new PropertyConfigurator(getDefaultPropertyConfigurator()).doConfigure(prop, hierarchy); // 配置log4j环境


### 2/20/2017 10:09:06 AM 

- 贪婪组件
	- 什么是贪婪组件？ 
		- DomainPanel.isFocusGreedyComponent(String componentId) 绑定了关闭出口的，componentId有“退出”和“取消”的是贪婪组件。

	- 贪婪组件有什么用处？
		- 
		
- 中文半角和全角输入的区别
	1. 一个汉字要占两个英文字符的位置，人们把一个英文字符所占的位置称为“半角”，相应地把一个汉字所占的位置称为“全角”。在汉字输入时，系统提供“半角”和“全角”两种不同的输入状态，但是对于英文字母、符号和数字这些通用的字符就不同于汉字，在半角状态他们被作为英文字符处理；而在全角状态，它们又可作为中文字符处理。
	2. 全角占两个字节，半角占一个字节。

- WatchService
	1. WatchService可以帮助我们监控一些文件是否做了更改，可以帮助我们去做一些响应。比如，配置文件修改了，那么系统应该重新加载一些配置文件。
	2. WatchServicePlugin.getAdvancedWatchService().register // FileMonitor类 61行

### 2/21/2017 11:03:33 AM 

- HotKey NavigationAction 分析
	- AdoreDisplay.getCurrent().addFilter(Event.KEY_DOWN,hotKey.getKeyDownHandler()); // GuiView 619行 注册按键按下事件
	- eventFilterMap.get(eventType).accept(e); // AdoreDisplay 224行 触发按键按下事件

- TradeActionRegistry TableNavigationAction
	- IABExtensionPoint point = ExtensionRegistryFactory.getRegistry().getExtensionPoint("cn.com.agree.ab.a4.client.gui.adore.tradeAction"); //GuiView 399行
	- targetTradeActionRegistry = new TradeActionRegistry();
	<pre>
		    // 组件级热键  Hotkey 260行
            if (component != null && runActions(component.getActions(strokes), domainPanel,component, strokes, event)) {
                return true;
            } 

		    private boolean runActions(List<IPanelAction> actions,
                               DomainPanel domainPanel, IController component,
                               List<String> keyStrokes, Event event) {
        		for (int i = 0; i < actions.size(); i++) {
            		IPanelAction action = (IPanelAction) actions.get(i);
            		if (action.run(host, domainPanel, component, keyStrokes, event)) {
                	return true;
            		}
        		}
        		return false;
    		}

	</pre>

### 2/23/2017 9:39:42 AM 

- 双击Button的各个出口解析
	1. 出口，正常出口和关闭出口。正常出口和关闭出口之后的流程就是按照mpt的连线继续下去。
	2. 流程，即是绑定lfc
	3. 关闭出口，画面关闭，不关联lfc。
	4. 流程出口，画面不关闭，关联lfc
		1. 流程：能回到画面。流程出口：执行流程从出口出去
	5. 流程关闭，画面关闭，关联lfc

### 2/24/2017 2:44:20 PM 

- InvokeRequest InvokeResponse issue 分析
	- 图片: C:\Users\canno30\Desktop\biji-note-\res\Invoke.png


- 如果lfc中存在服务器逻辑组件，那么该lfc剩下流程都会在服务器端执行。

- On_Init事件执行之前，画面已经初始化完成了。

### 2/27/2017 2:54:18 PM 

- 画面关闭的意思是，DomainPanel的close

- AsyncOpenTrade SyncOpenTrade的区别
	1. AsyncOpenTrade 异步打开交易，originalCallback，在代码执行的时候，已经return了。
		
			callback.call(new CommandResult(ProcessResult.END_SUCCESS).addMore(
				"tradeId", domain.getId()));

	2. SyncOpenTrade 同步打开交易 


			Callback<ProcessResult> callback = new Callback<ProcessResult>(
				exceptionHandler) {
				public void call(ProcessResult t) {
					finish(parentDomain, domain, dataView, exportMapping,
							new ProcessResult(ProcessResult.END_SUCCESS),
							originCallback, currentPanel, currentTask);
				}
			};
	> 同步打开交易，需要在打开的交易，结束后，原始交易才能结束。


- 脱离文档流，以及overflow:auto 高度撑不开

### 3/1/2017 10:35:41 AM 

- 如何实现文本框的必输属性
	- IDE中为文本框选择必输属性
	- <Entry key="requisite" type="Boolean" value="true"/>

- 焦点转移分析
	1. 实现例子，使用鼠标令焦点从Button4，跳转到Text2中。
	2. 首先，当鼠标切换控件的时候，会触发Focus控件的FocusPolicy事件
	3. 创建BusyPhase，offer(TaskPack taskPack) 加入了adoreloading，以及PointedFocusTaskPack两个任务
	4. 中间会执行performContent方法
		1. TaskPack.rootTask()
		2. FocusTaskPack.performContent()
		3. 执行了跳转到目标控件前，需要做得一些校验。

	5. 最后这个执行performControlFinal实现焦点的转移


### 3/4/2017 10:02:07 AM 

- flow日志，记录的是

		log4j.logger.log.cn.com.agree.ab.pub=debug, flow


- log.cn.com.agree.ab.a4.pub.FlowLog 包

### 3/6/2017 2:07:07 PM 

- Component的创建，以及组件的删除解析
	1. DomainPanel.uiBuildModel(UIModel model, Element[] entries, Element[] beans, boolean clear)
	2. 参考DomainPanel的这个方法可知，这个类首先入参是ContentBean，
		1. 执行Entry的解析，保存数据进入ContentBean的UIModel中
		2. 此方法的Element[] beans入参是ContentBean的子级Bean
		3. 遍历Beans，递归调用uiBuildModel(childModel,childEntries,XmlUtils.getChildrenElementsIgnoreCase(childBean,"Bean"), clear);
		4. 最后ContentBean的UIMdoel就addChild。model.addChild(childModel);
	3. DomainPanel.uiSetContentModel(UIModel contentModel)
		1. 作用就是利用ContentBean的UIModel,生成contentController
		2. AbstractController.addChild(IController child)
		3. 递归child.addNotify(); 利用儿子的UiModel生成Controller，然后利用Controller生成View
	

### 3/7/2017 9:44:37 AM 

- 何时平台会弹出Dialog
- 何种原因会弹出Dialog
- 何种原因会创建一个BusyPhase

<pre>
GuiView.java

		String defaultTadPath = getDefaultTadPath();
		if (defaultTadPath != null && defaultTadPath.trim().length() != 0) {
			createTrade(defaultTadPath, true);
		} else {
			PanelMessageBox.openBox(null, ADORE.Normal,
					PanelMessageBox.TYPE_ERROR, "没有配置入口交易,请配置好后重启客户端!",
					new String[] { "确定" }, null);
		}
</pre>

- 这段代码说明了只要abc开始找不到TadPath，就会出现MessageDialog。

<pre>
BusyPhase.class

    private void performControlFinal() {
        domainPanelUpdate();
        Throwable error = contentTask.getLocal(Throwable.class);
        
        if (error instanceof ExitAndOpenTradeException ||
                error instanceof ExitTradeException) {
            domainPanel.getTask().end(error);
        } else if (!(error instanceof ExitEventException)) {
            if (error != null)
            {
                // TODO 显示错误信息
                if(error instanceof ProcessException){
                    ProcessException pe = (ProcessException) error;
                    ExceptionStack es = pe.getSubExceptionStack();
                    displayErrorDialog(pe.getMessage(),es.toString());
                }
            }
            contentTask.set(Throwable.class, null);
        }
    }
</pre>

- 这个类说明，只要Mission中出现异常了，就会出现MessageDialog。


### 3/14/2017 8:15:26 PM 

- 异常断点
	- 设置异常断点，Eclipse就会在程序出现异常的时候，自动挂起。

### 3/15/2017 9:32:20 AM 

- 一般组件被调用了setAttribute(String key, Object value, String methodName)；
- 上方法调用了produceJS(JSONObject args, String methodName)；
- String scriptStr = display.getAdoreBrowser().evaluateWidgetJS(this,args, methodName);

	    if(widget.isBatch()) {
        	return function;
        }

- 如果batchJS 为true，最终由Container.flushJS发起批量执行，执行完毕后batchJS重置。
- 入股barchJS为false，那么就单个组件，独自执行js

### 3/15/2017 2:28:12 PM 

- BusyPhase这个类
	- performContent这个方法的分析
	- 拿出任务包执行，busyPhase中的任务都要执行完。
	- 自动移动焦
	- 点，创建一个PointedFocusTaskPack

- Group 的 SetEnabled 设置为不可用
	- enableWidet(boolean enabled);
	- group会重构
<pre>
    protected void enableWidget(boolean enabled) {
        for (Widget widget : children) {
            widget.enableWidget(enabled && widget.getEnabled());
        }
    }
</pre>

- 同步打开交易，异步打开交易。 AdoreDisplay.getCurrent().syncExec和 AdoreDisplay.asyncExec(Runnable runnable)
	- 所谓的同步打开交易和异步打开交易，其实就是CommandHandler的callback是否接受

<pre>
        AdoreDisplay.getCurrent().asyncExec(new Runnable() {
            public void run() {
                PanelMessageBox.openBox(panel, ADORE.INFORMATION | ADORE.MODAL, type, content, null, dialogCallback);
                // 就是说，以上代码 会执行带display.batchExecJs(); asyncExec，因为生成dialog是异步执行的，所以会执行以下的线程沉睡
                try {
					Thread.sleep(10000);
				} catch (InterruptedException e) {
					e.printStackTrace();
				} 
                System.out.println("ninihao");
            }
        });
        System.out.println("haha"); 
        // 正常来说，异步执行js，回立即返回，执行下面的操作
</pre>

- 控制台的输出是 “haha” 然后就是 “ninihao”

<pre>
haha
require(["widget/MessageDialog","util/WidgetManager","event/ExecutorEvent"],function(MessageDialog,WidgetManager,ExecutorEvent){ try{
ExecutorEvent.ExecutorEvent.finish("ExecutorEventdm5kfukhw7no");
var MessageDialogdm5kfukhw7np = new MessageDialog.MessageDialog("Compositedm5kfukhw7ok", "MessageDialogdm5kfukhw7np", 1207959552 );
MessageDialogdm5kfukhw7np.setMessageType({"messageType":"information"});
MessageDialogdm5kfukhw7np.setModal({"modal":true});
MessageDialogdm5kfukhw7np.setTitle({"title":"提示"});
MessageDialogdm5kfukhw7np.setMessage({"message":"小红逗比"});
MessageDialogdm5kfukhw7np.setButtonTexts({"buttonTexts":"确定"});
MessageDialogdm5kfukhw7np.show({});

 }catch(_ee){console.error(_ee);
ExecutorEvent.ExecutorEvent.error("ExecutorEventdm5kfukhw7no",_ee);}});
ninihao
</pre>

### 3/16/2017 3:55:06 PM 

- Img标签
	- 问题：上传一张图片，通过js更新src属性刷新图片使其即时显示时，当img的src当前的url与上次地址无变化时（只更改图片，名称不变，不同图片名称相同）图片不变化（仍显示原来的图片）但通过firebug看图片已经变化，因为当src的地址不变时浏览器不会重新加载图片仍从缓存里面读取
	- 方法：只需每次刷新图片时，改变一下src的地址内容就行了，（1）通过前台变化，让js每次生成一个随机数作参数放在url后边,但该参数没有实际意义(2)每次请求到该图片页面时，从后台传一个随机数，前台获得该随机变量并放在url后边，该随机数也没有什么实际意义
	- let path = args.src + "?t = " + Math.random(); // 防止重复地址的图片设置不了的问题
	- this.$imgNode.attr("src", path);

- AdoreDisplay.getCurrent().syncExec 和 AdoreDisplay.getCurrent().asyncExec 卡住界面
- CommandHandler中的callback 是卡住线程

### 3/17/2017 1:34:46 PM 

- 写程序也好，读别人写的程序也好
	- 首先就是需要写一些笔记，记录你思考的点点滴滴。


- 平台如何获取第一个组件
<pre>
	private IController findFirstFocusController() {
		// 找第一个可以获取焦点的组件
		IController focusController = TraverseUtils
				.getBottomFirstChild(rootController);
		if (focusController.getParent() == rootController) {
			return null;
		}
		if (!TraverseUtils.isControllerFocusable(focusController)) {
			focusController = TraverseUtils.getTraverseTarget(focusController,
					true);
		}
		return focusController;
	}
</pre>

- 当一个空的Abf4a，RootController的儿子是CONTENT

<pre>
    public static IController getBottomFirstChild(IController candidate) {
        while (candidate.getChildren().size() > 0) {
            candidate = (IController) candidate.getChildren().get(0);
        }
        return candidate;
    }
</pre>

RootController首先会找到第一个CONTENT，然后CONTENT会找到第一个控件，或者第一个Composite等容器。当找到是控件的时候，就没有儿子，结束。如果是Composite，即还是有儿子的，继续执行。

- TraverseUtils.isControllerFocusable(IController target) 这个方法用于判断这个控件是否可以获取焦点的。
	
		return (targetVisible[0] && targetEnabled && (targetStyle[0] & ADORE.NoFocus) == 0);

- 最后判断这个控件是否可以获取焦点，由以上三个条件判断
	1. 是否可见
	2. 是否可用
	3. style决定

<pre>
        targetControl.getDisplay().syncExec(new Runnable() {
            public void run() {
                if (targetControl.isDisposed()) {
                    targetVisible[0] = false;
                    targetStyle[0] = 0;
                } else {
                    targetVisible[0] = targetControl.isVisible();
                    if (!targetVisible[0]) {
			           //检查是否因为tab的原因
                        Container parentWalker = null;
                        boolean childOfTab = false;
                        for (parentWalker = targetControl.getParent(); parentWalker != null; parentWalker = parentWalker
                                .getParent()) {
                            if (parentWalker.getParent() instanceof TabFolder) {
                                childOfTab = true;
                                break;
                            }
                        }
                        if (childOfTab) {
                            // 当仅仅由于tab导致不可见时，才允许视为可见
                            targetVisible[0] = !parentWalker.isVisible()
                                    && parentWalker.getParent().isVisible();
                        }
                    }
                    targetStyle[0] = targetControl.getStyle();
                }
            }
        });
</pre>

这段代码主要是用于判断这个控件是否存在TabFolder的原因，使得其儿子visiable为false。

- package net.test;下有个HelloWorld.java
<pre>
1.编译
      编译的指令是javac
      编译方式：文件根目录 javac 文件名.java
比如：文件名字：HelloWorld.java
          文件路径：c:\net\test\HelloWorld.java
          文件包名：net.test
编译过程：
cmd 回车
cd c:\net\test 回车
javac HelloWorld.java 回车   将生成一个HelloWorld.class的文件

2. 运行
运行时候需要注意了，不能文件的根目录，是到文件的包目录的上层目录——可以理解为工程目录下，然后运行，文件名前需要加上包名。
运行过程：
cmd 回车
C:\ 回车, 退回到根目录
java   net.test.HelloWorld 回车   
</pre>

### 3/18/2017 10:08:03 AM 

- FocusTaskPack

- checkRequisite方法
	- 检查为输入的必输域，如果发现，则修改domainPanel的focusingId

- 想了解FoucsTaskPack类
	- 主要是看performContent这个方法
	- 首先是触发performOnBlur方法
		- 了解performOnBlur方法
		- 首先是找上一个控件FocusedId，如果找不到就结束；
			<pre>
				// 0.1. 已经逻辑无焦
        		final String focusedId = getDomainPanel().getFocusedId();
        		if (focusedId == null)
        		{
            		return;
        		}
			</pre>
		- 如果当前控件是一个贪婪控件，则不需要检验上一个焦点所绑定的事件。直接return;
			<pre>
				// 0.2. 等同逻辑无焦
        		final IController currentFocusedController = getDomainPanel()
                	.findControllerById(focusedId);
       			if (currentFocusedController == null
                	|| getDomainPanel().isFocusGreedyComponent(getFocusTarget()))
        		{
            		return;
        		}
			</pre>
		- performOnBlur方法里面，是需要检验当前焦点所在的控件是否是必输performOnBlur_CheckRequisite(currentFocusedController,onBlurTask);
	- 其次是触发performOnFocus方法
		- 这个方法里面也是需要校验必输
		- performOnFocus_CheckRequisite();


- PointedFocusTaskPack这个类中的isMovingBackward是否移动到前面
	- 如果isMovingBackward为false，就是向下，true，就是向上。
	- 其中getControllerIndexPath这个方法主要作用是获取
	<pre>
    private static List<Integer> getControllerIndexPath(IController controller)
    {
        IController parent = controller.getParent();
        if (parent == null)
        {
            return new ArrayList<Integer>();
        }
        List<Integer> indexPath = getControllerIndexPath(parent);
        indexPath.add(parent.getChildren().indexOf(controller));
        return indexPath;
    }		
	</pre>

### 3/20/2017 9:46:08 AM 

- 为abc提供首选项列表，即是像Eclipse的“选择主菜单"窗口---->首选项"命令打开"首选项"窗口.此窗口是Eclipse设置项的集中营”。
	- org.eclipse.ui.preferencePages 是首选项(Preference)的扩展点
	- name是首选项的树节点显示的名称.
	- class是首选项的树节点所对应的类(还没编写,下一步将完成此类)
	- id是首选项的树节点标识.建议设置成和class一样的名称.
	- category是父节点的id标识,当然,父节点要存在才行.

- PreferenceClient.checkStamp(String newStamp) 如果加载的是两个不同的交易，那么这个方法就会把PreferenceService中保存的数据都删除掉了。
		<pre>
	        String[] children = instancePrefs.childrenNames();
            for (int i = 0; i < children.length; i++)
            {
                IABPreferences child = instancePrefs.node(children[i]);
                child.clear();
                child.flush();
            }
		</pre>

- org.eclipse.jface.preference.IPreferenceStore 与 org.eclipse.core.runtime.preferences.IPreferencesService的区别
	- org.eclipse.core.runtime.prederences包提供了用于存储插件的首选项的基础结构。首选项通常映射至工作台首选项页面上受用户控制的设置，尽管这不是底层基础结构所必需的。插件首选项是键／值对，其中键描述首选项的名称，而值是几种不同类型的其中一种（boolean、double、float、int、long或 string）。可以存储首选项，并由平台从文件系统中检索到。**已保存的首选项的准确位置取决于首选项的作用域**。
	- 首选项的作用域与首选项的存储位置紧密相关。插件开发者可以决定为哪些标准作用域申请它们的首选项，也可以定义对于它们的插件有意义的新作用域。
		- 实例范围的首选项是按工作空间或平台的运行实例存储的。
			<pre>
			public IABPreferences getInstancePreferences() {
				return new ABPreferences(service.getRootNode().node(InstanceScope.SCOPE));
			}
			</pre>
		- 配置范围的首选项是按平台的安装存储的。各个工作空间将共享它们。例如，如果用户具有平台的单个安装，但是运行几个不同的工作空间，则配置级别范围的首选项将在工作空间之间共享。

### 3/22/2017 11:15:29 AM 

- 如何写出优雅的Java代码
	- 尽量不要写出魔法数字
		- 不要使用魔法数字，尽量定义枚举、常量、宏
		- 我常常见到表示各种状态的数字，0，1，2....，我真的不知道这表示什么含义
	- 命名要具有描述力，尽量使用全名而不是自创的缩写宁可容忍超过40个字符的命令，也不愿意 看到只有一两个字母的命名，当然迭代用的i,j除外。当然命名不要太长，太长说明你的类和方法要做的事情太多，请你拆分出更多细粒度功能单一的类和方法。
	- 函数、类功能尽可能单一，不要试图写一个万能/超级函数或者类。 
	- 你做一件事情，你就写一个对应的方法，不要试图通过参数来判定各种情况，然后做事情。并且做的事情和你方法描述的不一致。
		- 当你发现你的方法名字想不出来好的名字了，或者要加or和and了，那么请你拆分出更多单一的方法。 
		- 我最恶心根据参数，然后一大堆的if..else 和switch..case判断。
	-  多用抽象，分离，不要在修改一个固有的类和方法。


- MVC全名是Model View Controller，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。比如一批统计数据可以分别用柱状图、饼图来表示。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。

- New Plug-in from Existing JAR Achives
	- 从jar包生成一个plugin插件
	- New -> New Plug-in from Existing JAR Achives


### 3/23/2017 1:45:46 PM 

- 插件是否成功更新可以查看UpdateSchedule.java
	- check plugin list `checkDownloadList(monitor);`
	- download (notice downloaded) `download(monitor);`
	- compute dependency  计算依赖 `compute dependency  计算依赖`
	- prompt upgrade `prompt upgrade`

- CacheCommandLogiclet ExecuteCommandLogiclet 区别
	- ExecuteCommandLogiclet 发生错误的时候，会立刻出现MessageDialog
	- CacheCommandLogiclet 发生错误的时候，不会出现MessageDialog

- Workspace里面的东西，都会load到内存里面，这个与GRM有关

- JavaScript上下文与作用域
	- 执行上下文决定了Js执行过程中可获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。

### 3/24/2017 1:52:16 PM 

- GlobalResourceMap ABS启动的时候
	1. ResourceServer预加载的start方法启动
	2. ResouceManager.getDefault().init()
	3. ResourceManager.getDefault().initFileMonitor();
	4.  复位GRM resetGlobalResourceMap();
	5. GlobalResourceMap newGRM = new GlobalResourceMap(resourceClient != null);
	<pre>
	public GlobalResourceMap(boolean tryLoad)
    {
        if (!tryLoad || !initByLoading())
        {
            try
            {
                initByScanning();
            } catch (Exception e)
            {
                logger.error("初始化GRM失败," + e.getMessage(), e);
            }
        }
    }

    private void initByScanning() throws IOException
    {
        // 1. 扫描目录
        scanDir(ResourceManager.getRoot(), "/");
        // 2. 生成map内容及stamp
        byte[] content = generateContent(pathToStamp);
        // 3. 保存map内容
        version = saveGRM(content);
        // 4. 设置head
        head(version);
    }
	</pre>
	1. pathToChildren 类型：Map<String, List<String>> pathToChildren = new ConcurrentHashMap<String, List<String>>()，作用是存放文件夹路径，文件路径
		<pre>
			例子：
			/FCBank/trade/Test/liujingyun/TestShowMessage=[/FCBank/trade/Test/liujingyun/TestShowMessage/Button_按钮_OnClick.lfc, /FCBank/trade/Test/liujingyun/TestShowMessage/TestShowMessage.abf, /FCBank/trade/Test/liujingyun/TestShowMessage/TestShowMessage.abf4a, /FCBank/trade/Test/liujingyun/TestShowMessage/TestShowMessage.tad]
		</pre>

	2. pathToStamp 类型为Map<String, String> pathToStamp = new ConcurrentHashMap<String, String>()，作用就是每个文件对应的md5。
		<pre>
			例子：
			/data/dataResource/公共/公共管理/公共应用/AmtAhr.ade=c29f784d8f96a867d516ecf6c6f44094
			/FCBank/trade/Trade/GAPS/middle/newVersDeposit/AcctNoChan/TxtbCustPwd_OnBlur.lfc=ca8dcd1d6433f4cb24683287a1a5825e
		</pre>

- GlobalResourceMap ABC客户端是如何生成的
	- 首先如果.grm目录下没有东西，或者没有.grm目录，就需要扫描本地workspace目录下的文件，生成HEAD和MAPXXXX文件。
	- 然后和远程abs的grm的version对比，如果不同就下载。

### 3/25/2017 4:57:40 PM 

- Mpt中的id与Tad文件中的id对应的画面要一致
	`<UIStep id="1" showId="1">
        <Entry id="xy_location" value="50,150"/>
        <Entry id="xy_size" value="200,40"/>
        <Out caption="正常出口" id="1" name="正常出口" next="2" targetTerminal="正常端口"/>
        <Out caption="关闭出口" id="2" name="Close"/>
        <Exception name="" next="" targetTerminal=""/>
    </UIStep>`

- Tad
	`<Node caption="" id="1" type="UIStep">
            <InArg name="path">"/_test/trade/CloseCurrentPanel/CloseCurrentPanel.abf4a"</InArg>
            <InArg name="target"/>
            <InArg name="title"/>
            <InArg name="targetArgMap"/>
            <Mappings path="/_test/trade/CloseCurrentPanel/CloseCurrentPanel.tad"/>
     </Node>`

- 资源部署和资源下载，是否同一个服务器？


### 3/27/2017 11:00:18 AM 

- 主题加载机制
	- GuiView.loadTheme() //加载交易的开始时候，先要加载主题
		<pre>
	private void loadTheme() {
		String defaultThemeName = AdoreThemeManager.getInstance()
				.getDefaultThemeName();
		AdoreThemeManager.getInstance().loadTheme(defaultThemeName);
	}			
		</pre>
		以上代码，是从工作空间中取值。然后加载主题。
		<pre>
	public String getDefaultThemeName() {
		if ("win32".equals(ABPlatform.getOS())) {
			return PreferencesServiceFactory.getService().getString(
					"cn.com.agree.ab.a4.client.gui.windows", IPrefKeys.THEME,
					"Default");
		} else if ("android".equals(ABPlatform.getOS())
				|| "Darwin".equals(ABPlatform.getOS())) {
			return PreferencesServiceFactory.getService().getString(
					"cn.com.agree.ab.a4.client.gui.mobile", IPrefKeys.THEME,
					"Default");
		}
		return null;
	}
		</pre>
		以上代码讲述了如何获取配置的主题的name。不同平台不同的key
		<pre>
		AdoreThemeManager.getInstance().loadTheme(defaultThemeName); //加载主题
		</pre>
		以上代码，是获取了要加载的css路径，然后生成一段js控制浏览器改变css

- Path
	- File System一般是树形结构，因此我们可以把Path理解为按顺序存储的一系列的名称（目录名称和文件名称）。目录结构中最高一层的目录名就是序列中 index为0的那一个，目录结构中最低一层的目录名或者文件名就是序列中index为n-1的那一个（这里n是路径中层次的数目）。
	<pre>
		Path path = Paths.get("E:/aaa/a.log");    // Microsoft Windows syntax    
	    //Path path = Paths.get("/home/joe/foo");    // Solaris syntax   
	    System.out.println("path.toString()--"+path.toString());     
	    System.out.println("path.getName(1)--"+path.getName(1));       
	    System.out.println(path.getName(0));     
	    System.out.println(path.getNameCount());     
	    System.out.println(path.subpath(0,2));     
	    System.out.println(path.getParent());     
	    System.out.println(path.getRoot()); 
	    Path path4 = Paths.get("E:/aaa");  
        System.out.println("path4: " + path4.resolve("b.log"));  
	
	</pre>
	结果
	<pre>
path.toString()--E:\aaa\a.log
path.getName(1)--a.log
aaa
2
aaa\a.log
E:\aaa
E:\
path4: E:\aaa\b.log	
	</pre>

<pre>
		//文件的递归
		Files.walkFileTree(start, new SimpleFileVisitor<Path>() {
			@Override
			public FileVisitResult preVisitDirectory(Path dir,
					BasicFileAttributes attrs) throws IOException {
				register(dir);
				return FileVisitResult.CONTINUE;
			}
		});
</pre>

- WatchService 文件更新监听机制
	- Java WatchService 服务提供API，可以注册你感兴趣的事件，当service 发现注册的事件后，就交给处理线程做处理。

- ThreadPoolExecutor
	- corePoolSize
		- 核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。

	- maxPoolSize
		- 当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。

	- keepAliveTime
		- 当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。

	- queueCapacity
		- 任务队列容量。从maxPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。

### 3/28/2017 10:59:30 AM 

- ResourceServer，ResourceManager，ResourceClient
	- IDE改变文件内容后，部署至服务器中
	- 服务器的GRM会发生变化，并且通知客户端更新GRM
	- 客户端重新打开交易，比对客户端的资源文件的stamp与GRM的stamp是否相等
	- 不相等就进入下载过程。

### 3/30/2017 10:45:49 AM 

- CSS属性的Display与Visibility

### 4/10/2017 3:16:23 PM 

- Eclipse导出插件如果出现以下问题

<pre>
1. ERROR in E:\Agree\src\ab\huishang\cn.com.agree.ab.a4.server.lfc.huishang\
2. src\cn\com\agree\ab\a4\server\lfc\huishang\UnionAPIServiceE111.java (at line 6)
	import com.union.api.TUnionTransInfo;	
</pre>

有可能是 com.union这个包所在的项目出现问题了

- 正常的插件build.properties应该是这样的
<pre>
source.. = src/
output.. = bin/
bin.includes = META-INF/,\
               .,\
               json-lib-2.4-jdk15.jar,\
               xmlpull_1_0_5.jar,\
               xstream-1.4.7.jar

</pre>
	
- 有问题的插件是这样子的
<pre>
bin.includes = META-INF/,\
               log4j-1.2.17.jar,\
               xstream-1.4.7.jar,\
               json-lib-2.4-jdk15.jar,\
               fastjson-1.1.17.jar,\
               xmlpull_1_0_5.jar

</pre>

可以看出，上面的build.properties并没有导出src源码

4/17/2017 7:08:27 PM 

- 内嵌OLE 
	
- OLE和ActiveX控件的支持
	- OLE是指在程序之间链接和嵌入对象数据。通过OLE技术可以在一个应用程序中执行其他的应用程序。