## 4/12/2017 10:51:01 AM 

- Java空指针类型
<pre>
public class Test {

	public static void main(String[] args){
		Map<String,Object> map = new HashMap();
		Boolean b = (Boolean) map.get("Checked");
		System.out.println(b); 
		Test test = new Test();
		test.addRow(0, b); 
	}
	
	public void addRow(int i,boolean b){
		System.out.println(i + "=====" + b); 
	}
}		
</pre>
明显上面的会抛出空指针，但是抛出空指针的不是在强制转化类型的时候抛出的，而是应为b为null，所以在test调用addRow方法的时候抛出的npe。	

## 4/18/2017 3:36:31 PM 

- Widget.checkWidget() 理解

<pre>
	protected void checkWidget() {
		if (display == null) {
			error(ADORE.ERROR_WIDGET_DISPOSED);
		}
		if (display.getThread() != Thread.currentThread()) {
			error(ADORE.ERROR_THREAD_INVALID_ACCESS);
		}
		if ((state & ID_NOT_EXIST) != 0) {
			error(ADORE.ERROR_ID_NOT_EXIST);
		}
		if ((state & DISPOSED) != 0)
			error(ADORE.ERROR_WIDGET_DISPOSED);
	}
</pre>

- Widget.checkWidget()方法通常都是与AdoreDisplay.getCurrent().asyncExec(Runnable runnable)
	- CommandHandler执行控件方法的时候，需要写在AdroreDisplay.getCurrent().asyncExec方法里面。因为执行控件方法的时候，都会首先checkWidget()。
	- checkWidget的时候，如果没有使用上述方法包裹的话。display.getThread()就是uiThread，而Thread.currentThread()即是LRT的线程。


----------
- [type="checkbox"] + label 其中的“+”，选择器选择兄弟节点。
- HTML的for属性使用介绍
	- for属性规定label与checkButton
	- for属性起到了事件转移的作用，当你单击了label的时候，相当于点击了input，就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。

## 4/19/2017 10:56:07 AM 

- 一个界面如果上面还有必输选项，点击按钮。会首先触犯按钮的PointedFoucsTaskPack，然后出发按钮的Click事件的MissionTaskPack。
- 这样平台就会抛出以下异常信息
<pre>
java.lang.Exception: 无法将焦点移动到:button1
	at cn.com.agree.ab.a4.client.gui.adore.task.TaskPack.performFocusCheck(TaskPack.java:118)
	at cn.com.agree.ab.a4.client.gui.adore.task.MissionTaskPack.performFocusCheck(MissionTaskPack.java:82)
	at cn.com.agree.ab.a4.client.gui.adore.task.TaskPack$3.run(TaskPack.java:161)
	at cn.com.agree.ab.a4.pub.runtime.realm.LogicRealmTask.execute(LogicRealmTask.java:330)
	at cn.com.agree.ab.a4.pub.runtime.realm.LogicRealmTask.run(LogicRealmTask.java:609)
	at cn.com.agree.ab.a4.pub.runtime.realm.LogicRealm.runDirectly(LogicRealm.java:502)
	at cn.com.agree.ab.a4.pub.runtime.realm.LogicRealm$2.run(LogicRealm.java:260)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)
</pre>
- 原因是因为TaskPack的performFoucsCheck中domainPanel.getFocusedId()没有变为button1
<pre>
        if (premisedFocusId == null
                || premisedFocusId.equals(domainPanel.getFocusedId()))
        {
            return;
        }
</pre>
- 以下解释原因，因为PointedFoucsTaskPack执行的时候，要进行必输校验，必输校验失败的话，就不会进行performOnFocus的相关操作(即是performOnFocus_ExecuteMission)。
> Button貌似是先触发focus监听器，然后才触发click监听器。

## 4/20/2017 3:38:00 PM 

- 单选按钮RadioButton介绍
- 为了让多个单选按钮，显示单选效果。就必须让单选按钮的name属性都一致。
- 用户点击Label的时候，触发RadioButton的选择效果。可以在Label标签中设置for属性，属性值为RadioButton的id值。

----------

- Log4j介绍
- Log4JLogFactory initHierarchy方法
<pre>
        try
        {
            url = new URL("platform:config/log4j.properties");
            is = url.openStream();
            if (is != null)
            {
                prop.load(is);
            }
        } catch (IOException e)
        {
        } finally
        {
            if (is != null)
            {
                try
                {
                    is.close();
                } catch (IOException e1)
                {
                }
            }
        }
</pre>
- 这里就是说，解析abc的configuration目录下的log4j.properties文件

<pre>
			PropertyWatchdog dog = new PropertyWatchdog(configFilename);
			dog.setDelay(PropertyWatchdog.DEFAULT_DELAY);
			dog.start();
</pre>

- 看门狗监听log4j.properties文件的变化。

### 4/24/2017 8:04:18 PM 

- Linux系统的中文格式为utf-8，而window是gbk。所以把linux文件复制到window的时候，需要把文件转码。
- 压缩Linux系统的时候，tar命令不能转码，zip可以把utf-8转为gbk。


### 4/25/2017 10:30:30 AM 

- 交易abs Remote Java Application abs如果要断点，断银行的交易的时候，而且逻辑组件是在abs的时候。有以下几个步骤断abs。
1. 首先把Linux的abs服务器 zip包下载下来。
2. 其次就是调用abs的debug.bat 
3. bat的参数，其实也是相当于普通jar包启动方式一样 java xxxx1 -jar xxxx2 其中的xxxx1就是启动参数， xxxx2 就是Main的入参。
4. 最后Eclipse的Remote Java Application的 port是要debug的port一样

### 4/27/2017 2:35:32 PM 

- CheckButton 在未输入域未输入的时候，也可以出发其点击事件。这个bug做一下处理
	1. 原始代码
	<pre>
	public List createPolicies(IController controller) {
        List list = super.createPolicies(controller);
        // 改变选中的时候会触发该事件
        list.add(new NormalModifyPolicy(controller, Event.MOUSE_UP) {
            // 鼠标松开的时候代码click动作完成了
        	@Override
            protected void handleModify(Widget widget, UIModel model, Event event) {
                // 获取选中情况
                String checked = (String) event.getValue(CHECKED);
                if (checked != null) {
                    // model
                    model.setValue(CHECKED, new Boolean("true".equals(checked)));
                    IMission mission = createDomainPanelMission(isSwitch ? IUIEventConstants.ON_CHANGE : IUIEventConstants.ON_CLICK);
                    mission.putArg("checked", "true".equals(checked));
                    getHost().getDomainPanel().queueTaskPack(
                            new MissionTaskPack(getHost().getDomainPanel(),
                                    mission), QueueType.MAJOR);
                }
            }
        });

        return list;
    }
	</pre>
	1. 以上代码出现问题是，因为绑定是Policy，只要TS端发送了Event.MOUSE_UP就会触发这个事件。
	2. CheckButton.setChecked方法中
		<pre>this.checkbox.checked = this.checked;可以是CheckButton打钩或取消打钩</pre>
	3. 现在修复的写法是
	<pre>
	public List createPolicies(final IController controller) {
		List list = super.createPolicies(controller);
		// 改变选中的时候会触发该事件
		list.add(new NormalModifyPolicy(controller, Event.MOUSE_UP) {
			// 鼠标松开的时候代码click动作完成了
			@Override
			protected void handleModify(Widget widget, final UIModel model,
					Event event) {
				// 获取选中情况
				final String checked = (String) event.getValue(CHECKED);
				if (checked != null) {
					final IMission mission = createDomainPanelMission(isSwitch ? IUIEventConstants.ON_CHANGE
							: IUIEventConstants.ON_CLICK);
					mission.putArg("checked", "true".equals(checked));
					if (mission instanceof DummyMission) {
						/*
						 * 哑事件也得做必输校验，是为了解决上一个控件是必输控件且未输入时，
						 * checkButton仍然可以选中的bug
						 */
						mission.setRequisiteFocusId(controller.getId());
					}
					getHost().getDomainPanel().queueTaskPack(
							new MissionTaskPack(getHost().getDomainPanel(),
									mission) {
								protected void performContent() {
									/*
									 * 之所以在这里才修改model的值，是为了解决上一个控件是必输控件且未输入时，
									 * checkButton仍然可以选中的bug
									 */
									model.setValue(CHECKED,
											new Boolean("true".equals(checked)));
									super.performContent();
								}

								protected void fail(Throwable throwable) {
									// 哑事件直接fail即可，防止报异常日志
									if (mission instanceof DummyMission) {
										LogicRealmTask.getCurrent()
												.get(BusyPhase.class)
												.fail(new ExceptionHandler());
									} else {
										super.fail(throwable);
									}
								}
							}, QueueType.MAJOR);
				}
			}
		});

		return list;
	}		
	</pre>

## 5/1/2017 11:13:36 AM 

- DocumentEventInterceptor.initInterceptor 方法
<pre>
        $(document).on("keydown", (e: KeyboardEvent) => {
            if (e.keyCode === Keys.TAB) {
                e.preventDefault();
            }

            //对keydown的拦截监听
            let widget = WidgetUtil.findWidgetByTarget(e.target as HTMLElement);
            if (widget) {
                if (!widget.preHandleKeyDownEvent(e)) {
                    if (!DocumentEventInterceptor.handleHotKey(widget, e)) {
                        if (widget.isEnabled()) {
                            widget.handleKeyDownEvent(e, false);
                        }
                    } else {
                        // 过滤了就阻止事件进一步处理，并阻止事件冒泡
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            }
        })
</pre>

### 5/3/2017 8:22:48 PM 

- 操作Excel组件 poi以及jacob包
	- jacob（Java Com Bridge） 可以有界面地操作Excel，即可以打开Excel的打印界面。

### 5/23/2017 11:30:54 AM 

- BaiduMapUtil.ts 

		public static IsLoadedScript: boolean = false;
        //以上的代码相当于BaiduMapUtil.IsLoadedScript属性。BaiduMapUtil.IsLoadedScript = ture。相当于的Java的static 属性改变了，就是改变了内存中的值。

### JavaScrpit Web Worker

- 为了利用多核CPU的计算能力，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。

### 5/24/2017 11:41:36 AM 

#### 多窗口与窗体 ####

- 一个Web浏览器窗口可能在桌面上包含多个标签页，每个标签页都是独立的“浏览上下文”（browsing context），每一个上下文都有独立的Window对象。
- HEML文档经常使用&lt;iframe/&gt;来嵌套多个文档。由iframe所创建的嵌套浏览器上下文是用它自己的window对象所表示的。
- parent和top属性允许脚本引用它的窗体的祖先。
- &lt;iframe/&gt;元素有contentWindow属性，引用该窗口的window对象。

#### Web worker ####

- Web Workers处在一个自包含的执行环境中，无法访问Window对象和Document对象，和主线程之间的通信也只能通过异步消息传递机制来实现。并行地修改DOM是不可能的。
- Worker的postMessage和onMessage方法与WorkerGlobalScope的postMessage和onMessage方法作用相反。
- WorkerGlobalScope对象上定义的全局函数importScripts（）从来加载任何需要的库代码。接受一个或多个URL参数。